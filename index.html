<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RunPod ComfyUI Frontend</title>
  <style>
    :root{
      --bg: #0f1116; --panel:#171923; --muted:#a0abc0; --text:#e6eefc; --accent:#5aa9ff; --danger:#ff5964; --ok:#61d095; --border:#262b3a;
    }
    *{box-sizing:border-box}
    body{margin:0; font:14px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color:var(--text); background:var(--bg);}    
    header{position:sticky; top:0; z-index:5; background:rgba(15,17,22,.85); backdrop-filter:saturate(180%) blur(10px); border-bottom:1px solid var(--border);}    
    header .wrap{max-width:1100px; margin:0 auto; padding:10px 16px; display:flex; gap:12px; align-items:center; flex-wrap:wrap}
    header h1{font-size:16px; margin:0; font-weight:650}
    header .desc{color:var(--muted); font-size:12px}
    main{max-width:1100px; margin:0 auto; padding:16px; display:grid; grid-template-columns: 360px 1fr; gap:16px}
    @media (max-width: 880px){ main{grid-template-columns: 1fr;} }

    .card{background:var(--panel); border:1px solid var(--border); border-radius:12px; overflow:hidden}
    .card header{position:unset; background:none; border:0; display:flex; align-items:center; justify-content:space-between; gap:8px}
    .card .body{padding:14px}

    .row{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .row-3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px}
    .row-4{display:grid; grid-template-columns: repeat(4,1fr); gap:10px}

    label{display:block; margin:10px 0 4px; font-weight:600; font-size:12px; color:#cdd6eb}
    input[type="text"], input[type="number"], select, textarea{
      width:100%; padding:10px 12px; border-radius:9px; border:1px solid var(--border); background:#0c0e14; color:var(--text);
      outline:none; transition:border .15s ease;
    }
    input[type="file"]{
      width:100%; padding:8px 10px; border-radius:9px; border:1px solid var(--border); background:#0c0e14; color:var(--text);
    }
    input[type="file"]::file-selector-button,
    input[type="file"]::-webkit-file-upload-button{
      border:0; border-radius:8px; padding:8px 12px; margin-right:12px; background:#11305a; color:var(--text); cursor:pointer;
    }
    textarea{min-height:120px; resize:vertical}
    input[type="text"]:focus, input[type="number"]:focus, select:focus, textarea:focus{border-color:#33406b}

    .hint{color:var(--muted); font-size:12px}
    .muted{color:var(--muted)}

    .switch{display:inline-flex; align-items:center; gap:8px; cursor:pointer; user-select:none}
    .switch input{display:none}
    .switch .track{width:40px; height:22px; background:#0c0e14; border:1px solid var(--border); border-radius:999px; position:relative; transition:all .2s}
    .switch .thumb{position:absolute; top:1px; left:1px; width:18px; height:18px; border-radius:50%; background:#7b85a3; transition:left .2s}
    .switch input:checked + .track{background:#0d213c; border-color:#284e8a}
    .switch input:checked + .track .thumb{left:21px; background:var(--accent)}

    .btn{display:inline-flex; align-items:center; justify-content:center; gap:8px; border:1px solid var(--border); background:#0d1320; color:var(--text); padding:10px 12px; border-radius:10px; cursor:pointer; text-decoration:none}
    .btn:hover{border-color:#2f3b5f}
    .btn.primary{background:#11305a}
    .btn.danger{background:#2a1114}
    .btn:disabled{opacity:.6; cursor:not-allowed}

    .status{font-size:12px; color:var(--muted)}

    .gallery{display:grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap:12px; padding:12px}
    .shot{border:1px solid var(--border); background:#0c0e14; border-radius:10px; overflow:hidden}
    .shot header{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px; border-bottom:1px solid var(--border)}
    .shot img{display:block; width:100%; height:auto}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px}
    details pre{max-height:300px; overflow:auto; background:#0b0e14; border:1px solid var(--border); border-radius:8px; padding:12px}
    .error{color:var(--danger)}
  

/* --- Tabs --- */
.tabs{max-width:1100px; margin:8px auto 0; padding:0 16px; display:flex; gap:8px}
.tab{padding:8px 12px; border:1px solid var(--border); background:#0d1320; color:var(--text); border-radius:10px; cursor:pointer; user-select:none}
.tab.active{background:#11305a}
.hidden{display:none}

    .lightbox{position:fixed; inset:0; background:rgba(0,0,0,.8); display:flex; align-items:center; justify-content:center; z-index:1000; padding:20px;}
    .lightbox.hidden{display:none}
    .lightbox img{max-width:100%; max-height:100%; border-radius:8px}
    .lightbox .close{position:absolute; top:16px; right:16px; background:none; border:0; color:#fff; font-size:32px; cursor:pointer}

</style>
</head>
<body>
  <div id="lightbox" class="lightbox hidden"><img alt="Full size" /><button class="close" aria-label="Close">&times;</button></div>
  <header>
    <div class="wrap">
      <h1>RunPod ComfyUI Frontend</h1>
      <div class="desc">Static client for /runsync. No backend. API key stays in-memory.</div>
    </div>
  </header>

<nav class="tabs" id="tabbar">
  <button class="tab active" data-tab="sdxl">SDXL</button>
  <button class="tab" data-tab="qwen">Qwen-Image</button>
  <button class="tab" data-tab="ace">ACE-Step</button>
  <button class="tab" data-tab="wan">Wan 2.2 I2V</button>
</nav>

<div id="apiKeyWrap" style="max-width:1100px; margin:8px auto 0; padding:0 16px; display:flex; flex-wrap:wrap; justify-content:flex-end; gap:8px; align-items:center;">
  <label for="apiKey" style="margin:0">RunPod API Key</label>
  <input id="apiKey" type="text" placeholder="rp_..." autocomplete="off" spellcheck="false" style="width:300px" />
  <div class="hint" style="width:100%; text-align:right">Used only in this page, not stored.</div>
</div>


  <main>
    <section class="card" id="controls">
      <header class="body" style="border-bottom:1px solid var(--border)">
        <strong>Controls</strong>
        <div style="display:flex; gap:8px; align-items:center">
          <div class="status" id="timer">00:00.00</div>
          <div class="status" id="status">Idle</div>
        </div>
      </header>
      <div class="body">
        <label for="model">Model</label>
        <select id="model">
          <option value="noobaiXLNAIXL_vPred10Version.safetensors">noobaiXLNAIXL_vPred10Version.safetensors</option>
          <option value="Î£IH-1.5.safetensors">Î£IH-1.5.safetensors</option>
          <option value="midnightNAIXLVpredv1.safetensors">midnightNAIXLVpredv1.safetensors</option>
        </select>

        <label for="prompt">Prompt</label>
        <textarea id="prompt" placeholder="Describe the image..."></textarea>

        <div style="display:flex; align-items:center; justify-content:space-between; margin-top:8px">
          <label class="switch"><input id="negZero" type="checkbox"><span class="track"><span class="thumb"></span></span></label>
          <span class="hint">Zero out negative prompt</span>
        </div>

        <div id="negWrap">
          <label for="negative">Negative prompt</label>
          <textarea id="negative" placeholder="Things to avoid..."></textarea>
        </div>

        <div>
          <label for="dims">Dimensions</label>
          <select id="dims">
            <option>704x1408</option>
            <option>768x1344</option>
            <option>768x1280</option>
            <option>720x1280</option>
            <option>896x1152</option>
            <option>1024x1024</option>
            <option>1152x896</option>
            <option>1280x768</option>
            <option>1344x768</option>
            <option>1408x704</option>
          </select>
        </div>

        <div style="display:flex; align-items:center; justify-content:space-between; margin-top:8px">
          <label class="switch"><input id="rmbg" type="checkbox"><span class="track"><span class="thumb"></span></span></label>
          <span class="hint">Remove background (BiRefNet)</span>
        </div>

        <hr style="border:0; border-top:1px solid var(--border); margin:14px 0" />
        <strong></strong>
        <div class="row-3">
          <div>
            <label for="seed">Seed</label>
            <input id="seed" type="number" step="1" value="-1" />
            <div class="hint" id="seedHint">Use -1 for random</div>
          </div>
          <div>
            <label for="steps">Steps</label>
            <input id="steps" type="number" min="15" max="35" step="1" value="25" />
          </div>
          <div>
            <label for="cfg">CFG</label>
            <input id="cfg" type="number" step="0.1" value="5.0" />
            <div class="hint" id="cfgHint">Range 4.0â€“6.0 (non cfg_pp)</div>
          </div>
        </div>
        <div class="row">
          <div>
            <label for="sampler">Sampler</label>
            <select id="sampler"></select>
          </div>
          <div>
            <label for="scheduler">Scheduler</label>
            <select id="scheduler"></select>
          </div>
        </div>

        <hr style="border:0; border-top:1px solid var(--border); margin:14px 0" />
        <div style="display:flex; align-items:center; justify-content:space-between; margin:8px 0">
          <strong>HiresFix</strong>
          <label class="switch"><input id="hiresToggle" type="checkbox"><span class="track"><span class="thumb"></span></span></label>
        </div>
        <div id="hiresWrap" style="display:none">
          <div class="row-4">
            <div>
              <label for="hiresScale">Scale by</label>
              <input id="hiresScale" type="number" min="1.00" max="2.00" step="0.01" value="1.50" />
            </div>
            <div>
              <label for="hiresSteps">Steps</label>
              <input id="hiresSteps" type="number" min="15" max="25" step="1" value="20" />
            </div>
            <div>
              <label for="hiresCfg">CFG</label>
              <input id="hiresCfg" type="number" step="0.1" value="5.0" />
              <div class="hint" id="hiresCfgHint">Range 4.0â€“6.0 (non cfg_pp)</div>
            </div>
            <div>
              <label for="hiresDenoise">Denoise</label>
              <input id="hiresDenoise" type="number" min="0.00" max="1.00" step="0.01" value="0.56" />
            </div>
          </div>
          <div class="row">
            <div>
              <label for="hiresSampler">Sampler</label>
              <select id="hiresSampler"></select>
            </div>
            <div>
              <label for="hiresScheduler">Scheduler</label>
              <select id="hiresScheduler"></select>
            </div>
          </div>
          <div style="display:flex; align-items:center; justify-content:space-between; margin-top:8px">
            <label class="switch"><input id="hiresSeedCustom" type="checkbox"><span class="track"><span class="thumb"></span></span></label>
            <span class="hint">Use custom HiresFix seed</span>
          </div>
          <div id="hiresSeedWrap" style="display:none">
            <label for="hiresSeed">HiresFix seed</label>
            <input id="hiresSeed" type="number" step="1" value="-1" />
          </div>
        </div>

        <hr style="border:0; border-top:1px solid var(--border); margin:14px 0" />
        <div class="row">
          <button class="btn primary" id="runBtn">Generate</button>
          <button class="btn" id="curlBtn" type="button">Copy cURL</button>
        </div>
        <div class="row" style="margin-top:10px">
          <button class="btn" id="resetBtn" type="button">Reset to defaults</button>
          <button class="btn danger" id="clearBtn" type="button">Clear gallery</button>
        </div>
        <p class="hint" style="margin-top:10px">Endpoint: <span class="mono">https://api.runpod.ai/v2/vpr9pkvlr7n873/runsync</span></p>
      </div>
    </section>

    <section class="card">
      <header class="body" style="border-bottom:1px solid var(--border)"><strong>Output (AVIF)</strong></header>
      <div class="gallery" id="gallery"></div>
      <div class="body">
        <details>
          <summary class="mono">Request payload (debug)</summary>
          <pre class="mono" id="debugReq"></pre>
        </details>
        <details>
          <summary class="mono">Raw response (debug)</summary>
          <pre class="mono" id="debugResp"></pre>
        </details>
      </div>
    </section>
  </main>

<main id="qwen-main" class="hidden">
  <section class="card" id="q-controls">
    <header class="body" style="border-bottom:1px solid var(--border)">
      <strong>Qwen-Image Controls</strong>
      <div style="display:flex; gap:8px; align-items:center">
        <div class="status" id="q-timer">00:00.00</div>
        <div class="status" id="q-status">Idle</div>
      </div>
    </header>
    <div class="body">
      <div class="hint" style="margin-bottom:10px">
        Uses the same RunPod API key field above (rp_â€¦); endpoint identical to SDXL.
      </div>

      <label for="q-prompt">Prompt</label>
      <textarea id="q-prompt" placeholder="Describe the image..."></textarea>

      <div style="display:flex; align-items:center; justify-content:space-between; margin-top:8px">
        <label class="switch"><input id="q-lowstep" type="checkbox"><span class="track"><span class="thumb"></span></span></label>
        <span class="hint">Use low-step (forces steps=8; hides steps & negative)</span>
      </div>

      <div id="q-negwrap">
        <label for="q-negative">Negative prompt</label>
        <textarea id="q-negative" placeholder="Things to avoid..."></textarea>
      </div>

      <div class="row">
        <div>
          <label for="q-width">Width</label>
          <input id="q-width" type="number" min="64" max="1920" step="1" value="1024" />
        </div>
        <div>
          <label for="q-height">Height</label>
          <input id="q-height" type="number" min="64" max="1920" step="1" value="1024" />
        </div>
      </div>

      <hr style="border:0; border-top:1px solid var(--border); margin:14px 0" />
      <strong>Sampler</strong>
      <div class="row-3">
        <div>
          <label for="q-seed">Seed</label>
          <input id="q-seed" type="number" step="1" value="-1" />
          <div class="hint" id="q-seedHint">-1 = random (client-side)</div>
        </div>
        <div id="q-steps-wrap">
          <label for="q-steps">Steps</label>
          <input id="q-steps" type="number" min="10" max="30" step="1" value="20" />
        </div>
        <div>
          <label for="q-cfg">CFG</label>
          <input id="q-cfg" type="number" min="1.0" max="3.5" step="0.1" value="2.0" />
          <div class="hint">Always sent (even in low-step)</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="q-sampler">Sampler</label>
          <select id="q-sampler"></select>
        </div>
        <div>
          <label for="q-scheduler">Scheduler</label>
          <select id="q-scheduler"></select>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div>
          <label for="q-model-shift">Model shift</label>
          <input id="q-model-shift" type="number" min="0.00" step="0.01" value="3.10" />
          <div class="hint">Two decimal places</div>
        </div>
      </div>

      <hr style="border:0; border-top:1px solid var(--border); margin:14px 0" />
      <div class="row">
        <button class="btn primary" id="q-run">Generate</button>
        <button class="btn" id="q-curl" type="button">Copy cURL</button>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn" id="q-reset" type="button">Reset to defaults</button>
        <button class="btn danger" id="q-clear" type="button">Clear gallery</button>
      </div>
      <p class="hint" style="margin-top:10px">Endpoint: <span class="mono">https://api.runpod.ai/v2/vpr9pkvlr7n873/runsync</span></p>
    </div>
  </section>

  <section class="card">
    <header class="body" style="border-bottom:1px solid var(--border)"><strong>Output (AVIF)</strong></header>
    <div class="gallery" id="q-gallery"></div>
    <div class="body">
      <details>
        <summary class="mono">Request payload (debug)</summary>
        <pre class="mono" id="q-debugReq"></pre>
      </details>
      <details>
        <summary class="mono">Raw response (debug)</summary>
        <pre class="mono" id="q-debugResp"></pre>
      </details>
    </div>
  </section>
</main>

<main id="ace-main" class="hidden">
  <section class="card" id="ace-controls">
    <header class="body" style="border-bottom:1px solid var(--border)">
      <strong>ACE-Step Controls</strong>
      <div style="display:flex; gap:8px; align-items:center">
        <div class="status" id="ace-timer">00:00.00</div>
        <div class="status" id="ace-status">Idle</div>
      </div>
    </header>
    <div class="body">
      <div class="hint" style="margin-bottom:10px">
        Uses the same RunPod API key field above; dedicated endpoint for ACE-Step audio.
      </div>

      <label for="ace-tags">Tags</label>
      <textarea id="ace-tags" placeholder="Describe the song..."></textarea>

      <label for="ace-structure">Structure</label>
      <textarea id="ace-structure" placeholder="Describe the song structure..."></textarea>

      <label>Length (MM:SS)</label>
      <div class="row">
        <div>
          <label for="ace-minutes">Minutes</label>
          <input id="ace-minutes" type="number" min="0" step="1" value="0" />
        </div>
        <div>
          <label for="ace-seconds">Seconds</label>
          <input id="ace-seconds" type="number" min="0" max="59" step="1" value="30" />
        </div>
      </div>
      <div class="hint">Converted to total seconds before sending.</div>

      <div class="row-3">
        <div>
          <label for="ace-seed">Seed</label>
          <input id="ace-seed" type="number" step="1" value="-1" />
          <div class="hint" id="ace-seedHint">Use -1 for random</div>
        </div>
        <div>
          <label for="ace-steps">Steps</label>
          <input id="ace-steps" type="number" min="25" max="75" step="1" value="50" />
        </div>
        <div>
          <label for="ace-cfg">CFG</label>
          <input id="ace-cfg" type="number" min="1.0" step="0.1" value="5.0" />
          <div class="hint">Minimum 1.0</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="ace-sampler">Sampler</label>
          <select id="ace-sampler"></select>
        </div>
        <div>
          <label for="ace-scheduler">Scheduler</label>
          <select id="ace-scheduler"></select>
        </div>
      </div>

      <label for="ace-quality">Quality</label>
      <select id="ace-quality">
        <option value="96k">96k</option>
        <option value="128k" selected>128k</option>
        <option value="192k">192k</option>
      </select>

      <div class="row" style="margin-top:10px">
        <button class="btn primary" id="ace-run">Generate</button>
        <button class="btn" id="ace-curl" type="button">Copy cURL</button>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn" id="ace-reset" type="button">Reset to defaults</button>
        <button class="btn danger" id="ace-clear" type="button">Clear outputs</button>
      </div>
      <p class="hint" style="margin-top:10px">Endpoint: <span class="mono">https://api.runpod.ai/v2/e1hyz03h6llhvn/runsync</span></p>
    </div>
  </section>

  <section class="card">
    <header class="body" style="border-bottom:1px solid var(--border)"><strong>Output (Opus)</strong></header>
    <div class="gallery" id="ace-gallery"></div>
    <div class="body">
      <details>
        <summary class="mono">Request payload (debug)</summary>
        <pre class="mono" id="ace-debugReq"></pre>
      </details>
      <details>
        <summary class="mono">Raw response (debug)</summary>
        <pre class="mono" id="ace-debugResp"></pre>
      </details>
    </div>
  </section>
</main>


<main id="wan-main" class="hidden">
  <section class="card" id="wan-controls">
    <header class="body" style="border-bottom:1px solid var(--border)">
      <strong>Wan 2.2 I2V Controls</strong>
      <div style="display:flex; gap:8px; align-items:center">
        <div class="status" id="wan-timer">00:00.00</div>
        <div class="status" id="wan-status">Idle</div>
      </div>
    </header>
    <div class="body">
      <div class="hint" style="margin-bottom:10px">
        Upload an image, then generate an h265 MP4 video via the ACE-Step RunPod endpoint.
      </div>

      <label for="wan-prompt">Prompt</label>
      <textarea id="wan-prompt" placeholder="Describe the motion..."></textarea>

      <label for="wan-image">Source image</label>
      <input id="wan-image" type="file" accept="image/*" />
      <div class="hint" id="wan-image-hint">Select a PNG/JPG/WebP. It will be uploaded to /comfyui/input with a random filename.</div>

      <div style="display:flex; align-items:center; justify-content:space-between; margin-top:8px">
        <label class="switch"><input id="wan-nsfw" type="checkbox"><span class="track"><span class="thumb"></span></span></label>
        <span class="hint">Enable NSFW prompt routing</span>
      </div>

      <div style="display:flex; align-items:center; justify-content:space-between; margin-top:8px">
        <label class="switch"><input id="wan-lowstep" type="checkbox"><span class="track"><span class="thumb"></span></span></label>
        <span class="hint">Use low-step workflow (steps 4â€“8, CFG forced to 1.0)</span>
      </div>

      <div style="display:flex; align-items:center; justify-content:space-between; margin-top:8px">
        <label class="switch"><input id="wan-negzero" type="checkbox"><span class="track"><span class="thumb"></span></span></label>
        <span class="hint">Zero out negative prompt</span>
      </div>

      <div id="wan-neg-wrap">
        <label for="wan-negative">Negative prompt</label>
        <textarea id="wan-negative" placeholder="Things to avoid..."></textarea>
      </div>

      <div class="row" style="margin-top:4px">
        <div>
          <label for="wan-mp">Target megapixels</label>
          <input id="wan-mp" type="number" min="0.50" max="1.00" step="0.01" value="1.00" />
          <div class="hint">Range 0.50â€“1.00 MP</div>
        </div>
        <div>
          <label for="wan-length">Video length</label>
          <input id="wan-length" type="number" min="33" max="81" step="1" value="49" />
          <div class="hint">Frames, 33â€“81</div>
        </div>
      </div>

      <div class="row">
        <div>
          <label for="wan-steps">Steps</label>
          <input id="wan-steps" type="number" min="10" max="25" step="2" value="16" />
          <div class="hint" id="wan-steps-hint">Even numbers only</div>
        </div>
        <div id="wan-cfg-wrap">
          <label for="wan-cfg">CFG</label>
          <input id="wan-cfg" type="number" min="1.0" max="7.0" step="0.1" value="3.5" />
        </div>
      </div>
      <div class="hint" id="wan-cfg-note" style="display:none">CFG is forced to 1.0 while low-step is enabled.</div>

      <div class="row">
        <div>
          <label for="wan-sampler">Sampler</label>
          <select id="wan-sampler"></select>
        </div>
        <div>
          <label for="wan-scheduler">Scheduler</label>
          <select id="wan-scheduler"></select>
        </div>
      </div>

      <div style="display:flex; align-items:center; justify-content:space-between; margin-top:8px">
        <label class="switch"><input id="wan-interp" type="checkbox" checked><span class="track"><span class="thumb"></span></span></label>
        <span class="hint">Interpolate with RIFE after generation</span>
      </div>

      <div class="row" style="margin-top:14px">
        <button class="btn primary" id="wan-run">Generate</button>
        <button class="btn" id="wan-curl" type="button">Copy cURL</button>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn" id="wan-reset" type="button">Reset to defaults</button>
        <button class="btn danger" id="wan-clear" type="button">Clear outputs</button>
      </div>
      <p class="hint" style="margin-top:10px">Endpoint: <span class="mono">https://api.runpod.ai/v2/e1hyz03h6llhvn/runsync</span></p>
    </div>
  </section>

  <section class="card">
    <header class="body" style="border-bottom:1px solid var(--border)"><strong>Output (MP4)</strong></header>
    <div class="gallery" id="wan-gallery"></div>
    <div class="body">
      <details>
        <summary class="mono">Request payload (debug)</summary>
        <pre class="mono" id="wan-debugReq"></pre>
      </details>
      <details>
        <summary class="mono">Raw response (debug)</summary>
        <pre class="mono" id="wan-debugResp"></pre>
      </details>
    </div>
  </section>
</main>



  <!-- Workflow template embedded as JSON for robust placeholder replacement -->
  <script id="workflow-template" type="application/json">{
  "3": {"inputs": {"seed": "%seed%", "steps": "%steps%", "cfg": "%cfg%", "sampler_name": "%sampler%", "scheduler": "%scheduler%", "denoise": 1, "model": ["13", 0], "positive": ["6", 0], "negative": ["11", 0], "latent_image": ["5", 0]}, "class_type": "KSampler", "_meta": {"title": "KSampler (Initial)"}},
  "4": {"inputs": {"ckpt_name": "%model%"}, "class_type": "CheckpointLoaderSimple", "_meta": {"title": "Load Checkpoint"}},
  "5": {"inputs": {"width": "%width%", "height": "%height%", "batch_size": 1}, "class_type": "EmptyLatentImage", "_meta": {"title": "Empty Latent Image"}},
  "6": {"inputs": {"text": "%prompt%", "clip": ["4", 1]}, "class_type": "CLIPTextEncode", "_meta": {"title": "CLIP Text Encode (Prompt)"}},
  "8": {"inputs": {"samples": ["15", 0], "vae": ["4", 2]}, "class_type": "VAEDecode", "_meta": {"title": "VAE Decode"}},
  "9": {"inputs": {"filename_prefix": "ComfyUI", "filename_keys": "", "foldername_prefix": "", "foldername_keys": "", "delimiter": "-", "save_job_data": "disabled", "job_data_per_image": false, "job_custom_text": "", "save_metadata": false, "counter_digits": 4, "counter_position": "last", "one_counter_per_folder": true, "image_preview": true, "output_ext": ".avif", "quality": 99, "images": ["18", 0]}, "class_type": "SaveImageExtended", "_meta": {"title": "\ud83d\udcbe Save Image Extended"}},
  "10": {"inputs": {"conditioning": ["6", 0]}, "class_type": "ConditioningZeroOut", "_meta": {"title": "ConditioningZeroOut"}},
  "11": {"inputs": {"boolean": "%neg_zero_out%", "on_true": ["10", 0], "on_false": ["12", 0]}, "class_type": "easy ifElse", "_meta": {"title": "Zero Out Negative"}},
  "12": {"inputs": {"text": "%negative_prompt%", "clip": ["4", 1]}, "class_type": "CLIPTextEncode", "_meta": {"title": "CLIP Text Encode (Prompt)"}},
  "13": {"inputs": {"model": ["14", 0], "eta": 1, "norm_threshold": 20, "momentum": 0}, "class_type": "APG", "_meta": {"title": "Adaptive Projected Guidance"}},
  "14": {"inputs": {"model": ["4", 0]}, "class_type": "Mahiro", "_meta": {"title": "Mahiro"}},
  "15": {"inputs": {"boolean": "%use_hiresfix%", "on_true": ["17", 0], "on_false": ["3", 0]}, "class_type": "easy ifElse", "_meta": {"title": "Use HiresFix"}},
  "16": {"inputs": {"upscale_method": "nearest-exact", "scale_by": "%hiresfix_scale_by%", "samples": ["3", 0]}, "class_type": "LatentUpscaleBy", "_meta": {"title": "Upscale Latent By"}},
  "17": {"inputs": {"seed": "%hiresfix_seed%", "steps": "%hiresfix_steps%", "cfg": "%hiresfix_cfg%", "sampler_name": "%hiresfix_sampler%", "scheduler": "%hiresfix_scheduler%", "denoise": "%hiresfix_denoise%", "model": ["13", 0], "positive": ["6", 0], "negative": ["11", 0], "latent_image": ["16", 0]}, "class_type": "KSampler", "_meta": {"title": "KSampler"}},
  "18": {"inputs": {"boolean": "%remove_bg%", "on_true": ["19", 0], "on_false": ["8", 0]}, "class_type": "easy ifElse", "_meta": {"title": "Remove Background"}},
  "19": {"inputs": {"model": "BiRefNet_dynamic", "mask_blur": 0, "mask_offset": 0, "invert_output": false, "refine_foreground": false, "background": "Alpha", "background_color": "#000000", "image": ["8", 0]}, "class_type": "BiRefNetRMBG", "_meta": {"title": "BiRefNet Remove Background (RMBG)"}}
}
  </script>

<script id="wan-template" type="application/json">
{
  "1": {
    "inputs": {
      "unet_name": "wan2.2_i2v_high_noise_14B_fp8_scaled.safetensors",
      "weight_dtype": "default"
    },
    "class_type": "UNETLoader",
    "_meta": {
      "title": "Load High Noise"
    }
  },
  "2": {
    "inputs": {
      "unet_name": "wan2.2_i2v_low_noise_14B_fp8_scaled.safetensors",
      "weight_dtype": "default"
    },
    "class_type": "UNETLoader",
    "_meta": {
      "title": "Load Low Noise"
    }
  },
  "3": {
    "inputs": {
      "lora_name": "Wan21_I2V_14B_lightx2v_cfg_step_distill_lora_rank64.safetensors",
      "strength_model": 1,
      "model": [
        "10",
        0
      ]
    },
    "class_type": "LoraLoaderModelOnly",
    "_meta": {
      "title": "LoraLoaderModelOnly HN"
    }
  },
  "4": {
    "inputs": {
      "lora_name": "Wan21_I2V_14B_lightx2v_cfg_step_distill_lora_rank64.safetensors",
      "strength_model": 1,
      "model": [
        "13",
        0
      ]
    },
    "class_type": "LoraLoaderModelOnly",
    "_meta": {
      "title": "LoraLoaderModelOnly LN"
    }
  },
  "5": {
    "inputs": {
      "lora_name": "NSFW-22-H-e8.safetensors",
      "strength_model": 1,
      "strength_clip": 1,
      "model": [
        "1",
        0
      ],
      "clip": [
        "8",
        0
      ]
    },
    "class_type": "LoraLoader",
    "_meta": {
      "title": "NSFW H"
    }
  },
  "6": {
    "inputs": {
      "value": "%prompt%"
    },
    "class_type": "PrimitiveStringMultiline",
    "_meta": {
      "title": "Positive Prompt"
    }
  },
  "7": {
    "inputs": {
      "lora_name": "NSFW-22-L-e8.safetensors",
      "strength_model": 1,
      "strength_clip": 1,
      "model": [
        "2",
        0
      ],
      "clip": [
        "8",
        0
      ]
    },
    "class_type": "LoraLoader",
    "_meta": {
      "title": "NSFW L"
    }
  },
  "8": {
    "inputs": {
      "clip_name": "t5xxl_fp8_e4m3fn_scaled.safetensors",
      "type": "wan",
      "device": "default"
    },
    "class_type": "CLIPLoader",
    "_meta": {
      "title": "Load CLIP"
    }
  },
  "9": {
    "inputs": {
      "vae_name": "wan_2.1_vae.safetensors"
    },
    "class_type": "VAELoader",
    "_meta": {
      "title": "Load VAE"
    }
  },
  "10": {
    "inputs": {
      "boolean": [
        "11",
        0
      ],
      "on_true": [
        "5",
        0
      ],
      "on_false": [
        "1",
        0
      ]
    },
    "class_type": "easy ifElse",
    "_meta": {
      "title": "Is NSFW High"
    }
  },
  "11": {
    "inputs": {
      "value": "%is_nsfw%"
    },
    "class_type": "PrimitiveBoolean",
    "_meta": {
      "title": "Is NSFW"
    }
  },
  "12": {
    "inputs": {
      "value": "%low_step%"
    },
    "class_type": "PrimitiveBoolean",
    "_meta": {
      "title": "Low Step"
    }
  },
  "13": {
    "inputs": {
      "boolean": [
        "11",
        0
      ],
      "on_true": [
        "7",
        0
      ],
      "on_false": [
        "2",
        0
      ]
    },
    "class_type": "easy ifElse",
    "_meta": {
      "title": "Is NSFW Low"
    }
  },
  "14": {
    "inputs": {
      "boolean": [
        "12",
        0
      ],
      "on_true": [
        "3",
        0
      ],
      "on_false": [
        "10",
        0
      ]
    },
    "class_type": "easy ifElse",
    "_meta": {
      "title": "Low Step High"
    }
  },
  "15": {
    "inputs": {
      "boolean": [
        "12",
        0
      ],
      "on_true": [
        "4",
        0
      ],
      "on_false": [
        "13",
        0
      ]
    },
    "class_type": "easy ifElse",
    "_meta": {
      "title": "Low Step Low"
    }
  },
  "16": {
    "inputs": {
      "text": [
        "6",
        0
      ],
      "clip": [
        "8",
        0
      ]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "SFW Prompt"
    }
  },
  "17": {
    "inputs": {
      "text": [
        "18",
        0
      ],
      "clip": [
        "5",
        1
      ]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "NSFW PH"
    }
  },
  "18": {
    "inputs": {
      "string_a": "nsfwsks",
      "string_b": [
        "6",
        0
      ],
      "delimiter": ", "
    },
    "class_type": "StringConcatenate",
    "_meta": {
      "title": "Concatenate"
    }
  },
  "19": {
    "inputs": {
      "text": [
        "18",
        0
      ],
      "clip": [
        "7",
        1
      ]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "NSFW PL"
    }
  },
  "20": {
    "inputs": {
      "value": "%zero_out_negative%"
    },
    "class_type": "PrimitiveBoolean",
    "_meta": {
      "title": "Zero Out Negative"
    }
  },
  "21": {
    "inputs": {
      "text": "%negative_prompt%",
      "clip": [
        "8",
        0
      ]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "Negative Prompt"
    }
  },
  "23": {
    "inputs": {
      "boolean_a": [
        "12",
        0
      ],
      "boolean_b": [
        "20",
        0
      ]
    },
    "class_type": "Logic Comparison OR",
    "_meta": {
      "title": "Logic Comparison OR"
    }
  },
  "24": {
    "inputs": {
      "boolean": [
        "23",
        0
      ],
      "on_true": [
        "26",
        0
      ],
      "on_false": [
        "21",
        0
      ]
    },
    "class_type": "easy ifElse",
    "_meta": {
      "title": "Neg IfE"
    }
  },
  "25": {
    "inputs": {
      "conditioning": [
        "16",
        0
      ]
    },
    "class_type": "ConditioningZeroOut",
    "_meta": {
      "title": "ConditioningZeroOut"
    }
  },
  "26": {
    "inputs": {
      "boolean": [
        "11",
        0
      ],
      "on_true": [
        "27",
        0
      ],
      "on_false": [
        "25",
        0
      ]
    },
    "class_type": "easy ifElse",
    "_meta": {
      "title": "If else"
    }
  },
  "27": {
    "inputs": {
      "conditioning": [
        "17",
        0
      ]
    },
    "class_type": "ConditioningZeroOut",
    "_meta": {
      "title": "ConditioningZeroOut"
    }
  },
  "28": {
    "inputs": {
      "shift": 5,
      "model": [
        "14",
        0
      ]
    },
    "class_type": "ModelSamplingSD3",
    "_meta": {
      "title": "ModelSamplingSD3"
    }
  },
  "29": {
    "inputs": {
      "shift": 5,
      "model": [
        "15",
        0
      ]
    },
    "class_type": "ModelSamplingSD3",
    "_meta": {
      "title": "ModelSamplingSD3"
    }
  },
  "30": {
    "inputs": {
      "add_noise": "enable",
      "noise_seed": 0,
      "steps": [
        "32",
        0
      ],
      "cfg": "%cfg%",
      "sampler_name": "%sampler%",
      "scheduler": "%scheduler%",
      "start_at_step": 0,
      "end_at_step": [
        "33",
        0
      ],
      "return_with_leftover_noise": "disable",
      "model": [
        "28",
        0
      ],
      "positive": [
        "34",
        0
      ],
      "negative": [
        "34",
        1
      ],
      "latent_image": [
        "34",
        2
      ]
    },
    "class_type": "KSamplerAdvanced",
    "_meta": {
      "title": "KSampler High"
    }
  },
  "31": {
    "inputs": {
      "add_noise": "disable",
      "noise_seed": 0,
      "steps": [
        "32",
        0
      ],
      "cfg": "%cfg%",
      "sampler_name": "%sampler%",
      "scheduler": "%scheduler%",
      "start_at_step": [
        "33",
        0
      ],
      "end_at_step": [
        "32",
        0
      ],
      "return_with_leftover_noise": "disable",
      "model": [
        "29",
        0
      ],
      "positive": [
        "44",
        0
      ],
      "negative": [
        "34",
        1
      ],
      "latent_image": [
        "30",
        0
      ]
    },
    "class_type": "KSamplerAdvanced",
    "_meta": {
      "title": "KSampler Low"
    }
  },
  "32": {
    "inputs": {
      "value": "%steps%"
    },
    "class_type": "PrimitiveInt",
    "_meta": {
      "title": "Steps"
    }
  },
  "33": {
    "inputs": {
      "a": [
        "32",
        0
      ],
      "b": 2,
      "operation": "divide"
    },
    "class_type": "easy mathInt",
    "_meta": {
      "title": "Math Int"
    }
  },
  "34": {
    "inputs": {
      "width": [
        "66",
        1
      ],
      "height": [
        "66",
        2
      ],
      "length": [
        "43",
        0
      ],
      "batch_size": 1,
      "positive": [
        "35",
        0
      ],
      "negative": [
        "24",
        0
      ],
      "vae": [
        "9",
        0
      ],
      "start_image": [
        "66",
        0
      ]
    },
    "class_type": "WanImageToVideo",
    "_meta": {
      "title": "WanImageToVideo High"
    }
  },
  "35": {
    "inputs": {
      "boolean": [
        "11",
        0
      ],
      "on_true": [
        "17",
        0
      ],
      "on_false": [
        "16",
        0
      ]
    },
    "class_type": "easy ifElse",
    "_meta": {
      "title": "If else"
    }
  },
  "36": {
    "inputs": {
      "image": "%img%"
    },
    "class_type": "LoadImage",
    "_meta": {
      "title": "Load Image"
    }
  },
  "41": {
    "inputs": {
      "width": [
        "66",
        1
      ],
      "height": [
        "66",
        2
      ],
      "length": [
        "43",
        0
      ],
      "batch_size": 1,
      "positive": [
        "19",
        0
      ],
      "negative": [
        "24",
        0
      ],
      "vae": [
        "9",
        0
      ],
      "start_image": [
        "66",
        0
      ]
    },
    "class_type": "WanImageToVideo",
    "_meta": {
      "title": "WanImageToVideo Low"
    }
  },
  "43": {
    "inputs": {
      "value": "%length%"
    },
    "class_type": "PrimitiveInt",
    "_meta": {
      "title": "Length"
    }
  },
  "44": {
    "inputs": {
      "boolean": [
        "11",
        0
      ],
      "on_true": [
        "41",
        0
      ],
      "on_false": [
        "34",
        0
      ]
    },
    "class_type": "easy ifElse",
    "_meta": {
      "title": "Prompt Switch"
    }
  },
  "45": {
    "inputs": {
      "samples": [
        "31",
        0
      ],
      "vae": [
        "9",
        0
      ]
    },
    "class_type": "VAEDecode",
    "_meta": {
      "title": "VAE Decode"
    }
  },
  "46": {
    "inputs": {
      "ckpt_name": "rife49.pth",
      "clear_cache_after_n_frames": 10,
      "multiplier": 2,
      "fast_mode": true,
      "ensemble": true,
      "scale_factor": 1,
      "frames": [
        "45",
        0
      ]
    },
    "class_type": "RIFE VFI",
    "_meta": {
      "title": "RIFE VFI (recommend rife47 and rife49)"
    }
  },
  "47": {
    "inputs": {
      "frame_rate": [
        "50",
        0
      ],
      "loop_count": 0,
      "filename_prefix": "AnimateDiff",
      "format": "video/h265-mp4",
      "pix_fmt": "yuv420p10le",
      "crf": 20,
      "save_metadata": true,
      "pingpong": false,
      "save_output": true,
      "images": [
        "49",
        0
      ]
    },
    "class_type": "VHS_VideoCombine",
    "_meta": {
      "title": "Video Combine ðŸŽ¥ðŸ…¥ðŸ…—ðŸ…¢"
    }
  },
  "49": {
    "inputs": {
      "boolean": [
        "53",
        0
      ],
      "on_true": [
        "46",
        0
      ],
      "on_false": [
        "45",
        0
      ]
    },
    "class_type": "easy ifElse",
    "_meta": {
      "title": "If else"
    }
  },
  "50": {
    "inputs": {
      "boolean": [
        "53",
        0
      ],
      "on_true": [
        "52",
        0
      ],
      "on_false": [
        "51",
        0
      ]
    },
    "class_type": "easy ifElse",
    "_meta": {
      "title": "If else"
    }
  },
  "51": {
    "inputs": {
      "value": 16
    },
    "class_type": "PrimitiveInt",
    "_meta": {
      "title": "Int"
    }
  },
  "52": {
    "inputs": {
      "value": 24
    },
    "class_type": "PrimitiveInt",
    "_meta": {
      "title": "Int"
    }
  },
  "53": {
    "inputs": {
      "value": "%interpolate%"
    },
    "class_type": "PrimitiveBoolean",
    "_meta": {
      "title": "Interpolate with RIFE"
    }
  },
  "65": {
    "inputs": {
      "upscale_method": "lanczos",
      "megapixels": "%mp%",
      "image": [
        "36",
        0
      ]
    },
    "class_type": "ImageScaleToTotalPixels",
    "_meta": {
      "title": "Scale Image to Total Pixels"
    }
  },
  "66": {
    "inputs": {
      "width": [
        "67",
        4
      ],
      "height": [
        "67",
        5
      ],
      "upscale_method": "nearest-exact",
      "keep_proportion": "stretch",
      "pad_color": "0, 0, 0",
      "crop_position": "center",
      "divisible_by": 16,
      "device": "gpu",
      "image": [
        "65",
        0
      ]
    },
    "class_type": "ImageResizeKJv2",
    "_meta": {
      "title": "Resize Image v2"
    }
  },
  "67": {
    "inputs": {
      "image": [
        "65",
        0
      ]
    },
    "class_type": "Image Size to Number",
    "_meta": {
      "title": "Image Size to Number"
    }
  }
}
</script>

<script id="qwen-template" type="application/json">
{
  "1": {"inputs":{"unet_name":"qwen_image_fp8_e4m3fn.safetensors","weight_dtype":"fp8_e4m3fn"},"class_type":"UNETLoader","_meta":{"title":"Load Diffusion Model"}},
  "2": {"inputs":{"clip_name":"qwen_2.5_vl_7b_fp8_scaled.safetensors","type":"qwen_image","device":"default"},"class_type":"CLIPLoader","_meta":{"title":"Load CLIP"}},
  "3": {"inputs":{"vae_name":"qwen_image_vae.safetensors"},"class_type":"VAELoader","_meta":{"title":"Load VAE"}},
  "5": {"inputs":{"value":"%use_low_step%"},"class_type":"PrimitiveBoolean","_meta":{"title":"Low Step"}},
  "6": {"inputs":{"text":"%prompt%","clip":["2",0]},"class_type":"CLIPTextEncode","_meta":{"title":"CLIP Text Encode (Positive Prompt)"}},
  "7": {"inputs":{"text":"%negative_prompt%","clip":["2",0]},"class_type":"CLIPTextEncode","_meta":{"title":"CLIP Text Encode (Negative Prompt)"}},
  "8": {"inputs":{"width":"%width%","height":"%height%","batch_size":1},"class_type":"EmptySD3LatentImage","_meta":{"title":"EmptySD3LatentImage"}},
  "9": {"inputs":{"seed":"%seed%","steps":"%steps%","cfg":["20",0],"sampler_name":"%sampler%","scheduler":"%scheduler%","denoise":1,"model":["10",0],"positive":["6",0],"negative":["14",0],"latent_image":["8",0]},"class_type":"KSampler","_meta":{"title":"KSampler"}},
  "10": {"inputs":{"shift":"%model_shift%","model":["12",0]},"class_type":"ModelSamplingAuraFlow","_meta":{"title":"ModelSamplingAuraFlow"}},
  "11": {"inputs":{"lora_name":"Qwen-Image-Lightning-8steps-V2.0.safetensors","strength_model":1,"model":["1",0]},"class_type":"LoraLoaderModelOnly","_meta":{"title":"LoraLoaderModelOnly"}},
  "12": {"inputs":{"boolean":["5",0],"on_true":["11",0],"on_false":["1",0]},"class_type":"easy ifElse","_meta":{"title":"If else"}},
  "13": {"inputs":{"conditioning":["6",0]},"class_type":"ConditioningZeroOut","_meta":{"title":"ConditioningZeroOut"}},
  "14": {"inputs":{"boolean":["5",0],"on_true":["13",0],"on_false":["7",0]},"class_type":"easy ifElse","_meta":{"title":"If else"}},
  "15": {"inputs":{"samples":["9",0],"vae":["3",0]},"class_type":"VAEDecode","_meta":{"title":"VAE Decode"}},
  "16": {"inputs":{"filename_prefix":"Qwen","filename_keys":"","foldername_prefix":"","foldername_keys":"","delimiter":"-","save_job_data":"disabled","job_data_per_image":false,"job_custom_text":"","save_metadata":false,"counter_digits":4,"counter_position":"last","one_counter_per_folder":true,"image_preview":true,"output_ext":".avif","quality":99,"images":["15",0]},"class_type":"SaveImageExtended","_meta":{"title":"\ud83d\udcbe Save Image Extended"}},
  "20": {"inputs":{"boolean":["5",0],"on_true":["21",0],"on_false":["22",0]},"class_type":"easy ifElse","_meta":{"title":"If else"}},
  "21": {"inputs":{"value":1},"class_type":"PrimitiveFloat","_meta":{"title":"LSCFG"}},
  "22": {"inputs":{"value":"%cfg%"},"class_type":"PrimitiveFloat","_meta":{"title":"Standard CFG"}}
}
</script>

<script id="ace-template" type="application/json">
{
  "1": {
    "inputs": {
      "ckpt_name": "ace_step_v1_3.5b.safetensors"
    },
    "class_type": "CheckpointLoaderSimple",
    "_meta": {
      "title": "Load Checkpoint"
    }
  },
  "3": {
    "inputs": {
      "seconds": "%length%",
      "batch_size": 1
    },
    "class_type": "EmptyAceStepLatentAudio",
    "_meta": {
      "title": "EmptyAceStepLatentAudio"
    }
  },
  "7": {
    "inputs": {
      "tags": "%tags%",
      "lyrics": "%structure%",
      "lyrics_strength": 0.99,
      "clip": [
        "1",
        1
      ]
    },
    "class_type": "TextEncodeAceStepAudio",
    "_meta": {
      "title": "TextEncodeAceStepAudio"
    }
  },
  "8": {
    "inputs": {
      "seed": "%seed%",
      "steps": "%steps%",
      "cfg": "%cfg%",
      "sampler_name": "%sampler%",
      "scheduler": "%scheduler%",
      "denoise": 1,
      "model": [
        "11",
        0
      ],
      "positive": [
        "7",
        0
      ],
      "negative": [
        "9",
        0
      ],
      "latent_image": [
        "3",
        0
      ]
    },
    "class_type": "KSampler",
    "_meta": {
      "title": "KSampler"
    }
  },
  "9": {
    "inputs": {
      "conditioning": [
        "7",
        0
      ]
    },
    "class_type": "ConditioningZeroOut",
    "_meta": {
      "title": "ConditioningZeroOut"
    }
  },
  "10": {
    "inputs": {
      "shift": 5,
      "model": [
        "1",
        0
      ]
    },
    "class_type": "ModelSamplingSD3",
    "_meta": {
      "title": "ModelSamplingSD3"
    }
  },
  "11": {
    "inputs": {
      "model": [
        "10",
        0
      ],
      "operation": [
        "12",
        0
      ]
    },
    "class_type": "LatentApplyOperationCFG",
    "_meta": {
      "title": "ApplyOperationCFG"
    }
  },
  "12": {
    "inputs": {
      "multiplier": 1
    },
    "class_type": "LatentOperationTonemapReinhard",
    "_meta": {
      "title": "LatentOperationTonemapReinhard"
    }
  },
  "13": {
    "inputs": {
      "samples": [
        "8",
        0
      ],
      "vae": [
        "1",
        2
      ]
    },
    "class_type": "VAEDecodeAudio",
    "_meta": {
      "title": "VAEDecodeAudio"
    }
  },
  "14": {
    "inputs": {
      "filename_prefix": "audio/ComfyUI",
      "quality": "%quality%",
      "audioUI": "",
      "audio": [
        "13",
        0
      ]
    },
    "class_type": "SaveAudioOpus",
    "_meta": {
      "title": "Save Audio (Opus)"
    }
  }
}
</script>



  <script>
    const ENDPOINT = 'https://api.runpod.ai/v2/vpr9pkvlr7n873/runsync';
    const STATUS_ENDPOINT = ENDPOINT.replace('/runsync', '/status');
    const ACE_ENDPOINT = 'https://api.runpod.ai/v2/e1hyz03h6llhvn/runsync';
    const ACE_STATUS_ENDPOINT = ACE_ENDPOINT.replace('/runsync', '/status');
    const ACE_BASE_ENDPOINT = ACE_ENDPOINT.replace(/\/runsync$/, '');
    const ACE_FILE_ENDPOINT = `${ACE_BASE_ENDPOINT}/file`;
    const ACE_FILES_ENDPOINT = `${ACE_BASE_ENDPOINT}/files`;
    const ACE_RUNS_ENDPOINT = `${ACE_BASE_ENDPOINT}/runs`;
    const ACE_RUN_ENDPOINT = `${ACE_BASE_ENDPOINT}/run`;
    const WAN_ENDPOINT = ACE_ENDPOINT;
    const WAN_STATUS_ENDPOINT = ACE_STATUS_ENDPOINT;
    const WAN_BASE_ENDPOINT = ACE_BASE_ENDPOINT;
    const WAN_FILE_ENDPOINT = `${WAN_BASE_ENDPOINT}/file`;
    const WAN_FILES_ENDPOINT = `${WAN_BASE_ENDPOINT}/files`;
    const WAN_RUNS_ENDPOINT = `${WAN_BASE_ENDPOINT}/runs`;
    const WAN_RUN_ENDPOINT = `${WAN_BASE_ENDPOINT}/run`;
    const SAMPLERS = [
      'euler', 'euler_ancestral', 'euler_cfg_pp', 'euler_ancestral_cfg_pp',
      'heunpp2', 'lcm', 'dpmpp_2m', 'dpmpp_2m_cfg_pp', 'dpmpp_2s_ancestral', 
      'dpmpp_sde', 'dpmpp_2s_ancestral_cfg_pp', 'dpmpp_2m_sde_heun',
      'res_multistep', 'res_multistep_cfg_pp', 'res_multistep_ancestral_cfg_pp', 
      'sa_solver_pece', 'ipndm', 'deis', 'er_sde', 'seeds_2',
      'gradient_estimation', 'gradient_estimation_cfg_pp', 'uni_pc'
    ];
    const SCHEDULERS = ['normal', 'simple', 'sgm_uniform', 'karras', 'exponential', 'beta', 'zeta', 'linear_quadratic', 'kl_optimal'];

    function genRandomSeed(){
      if(window.crypto && crypto.getRandomValues){
        const buf = new Uint32Array(1); crypto.getRandomValues(buf);
        return (buf[0] >>> 0) || 1;
      }
      return Math.floor(Math.random()*2147483647) + 1;
    }

    function populateSelect(sel, options, def){
      if(!sel) return;
      sel.innerHTML = options.map(o => `<option>${o}</option>`).join('');
      if(def) sel.value = def;
    }

    function formatDuration(ms){
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      const hundredths = Math.floor((ms % 1000) / 10);
      return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(hundredths).padStart(2,'0')}`;
    }

    function makeTimer(el){
      let start = 0;
      let handle = null;
      function update(){
        if(!el) return;
        const diff = performance.now() - start;
        el.textContent = formatDuration(diff);
      }
      return {
        start(){
          start = performance.now();
          update();
          handle = setInterval(update, 30);
        },
        stop(){
          if(handle) clearInterval(handle);
          handle = null;
          update();
        }
      };
    }

    function formatBytes(bytes){
      const value = Number(bytes);
      if(!Number.isFinite(value) || value < 0) return '';
      if(value < 1024) return `${value} B`;
      if(value < 1024 * 1024) return `${(value / 1024).toFixed(1).replace(/\.0$/, '')} KB`;
      return `${(value / (1024 * 1024)).toFixed(1).replace(/\.0$/, '')} MB`;
    }

    function readFileAsBase64(file){
      return new Promise((resolve, reject) => {
        if(!file){ reject(new Error('No file provided')); return; }
        const reader = new FileReader();
        reader.onload = () => {
          const result = reader.result;
          if(typeof result !== 'string'){ reject(new Error('Unexpected file result')); return; }
          const comma = result.indexOf(',');
          const base64 = comma >= 0 ? result.slice(comma + 1) : result;
          const mimeMatch = /^data:([^;,]+)/i.exec(result);
          const mime = mimeMatch && mimeMatch[1] ? mimeMatch[1] : (file.type || 'application/octet-stream');
          let ext = '';
          if(file.name && file.name.includes('.')){
            ext = file.name.split('.').pop() || '';
          }
          if(!ext && mime){
            const mimeExt = mime.split('/').pop();
            if(mimeExt) ext = mimeExt.replace(/[^a-zA-Z0-9]/g, '');
          }
          if(!ext) ext = 'png';
          resolve({ base64, dataUrl: result, mime, extension: ext.toLowerCase() });
        };
        reader.onerror = () => reject(reader.error || new Error('File read error'));
        reader.readAsDataURL(file);
      });
    }

    function generateWanFilename(ext){
      const safeExt = (ext || 'png').toLowerCase().replace(/[^a-z0-9]/g, '') || 'png';
      const stamp = Date.now().toString(36);
      const rand = Math.random().toString(36).slice(2, 10);
      return `wan_${stamp}_${rand}.${safeExt}`;
    }

    function createWanUploadPacket(filename, info){
      const remotePath = `/comfyui/input/${filename}`;
      const remoteNoSlash = `comfyui/input/${filename}`;
      const base64 = info.base64;
      const mime = info.mime || 'image/png';
      const input = {
        filename,
        file_name: filename,
        fileName: filename,
        name: filename,
        originalName: filename,
        path: remotePath,
        file_path: remotePath,
        filePath: remotePath,
        full_path: remotePath,
        fullPath: remotePath,
        relative_path: remoteNoSlash,
        relativePath: remoteNoSlash,
        target: remotePath,
        destination: remotePath,
        folder: 'comfyui/input',
        directory: 'comfyui/input',
        filepath: remotePath,
        file: remotePath,
        data: base64,
        fileData: base64,
        filedata: base64,
        content: base64,
        contents: base64,
        base64,
        encoding: 'base64',
        mime,
        mimetype: mime,
        content_type: mime,
        contentType: mime,
        type: 'base64'
      };
      return {
        body: { input },
        remotePath,
        remotePathNoSlash: remoteNoSlash,
        remoteName: filename
      };
    }

    function parseWanUploadResult(data, fallbackName, fallbackPath){
      const initialPath = typeof fallbackPath === 'string' && fallbackPath ? fallbackPath : null;
      const result = {
        shortName: fallbackName,
        remotePath: initialPath,
        remotePathNoSlash: initialPath ? (initialPath.startsWith('/') ? initialPath.slice(1) : initialPath) : null
      };
      if(!data) return result;

      const visited = new WeakSet();
      let found = false;

      function applyPath(value){
        if(typeof value !== 'string' || found) return false;
        let trimmed = value.trim();
        if(!trimmed || trimmed.length > 4096) return false;
        if(trimmed.startsWith('data:')) return false;
        const sanitized = trimmed.replace(/\\/g, '/');
        const lower = sanitized.toLowerCase();

        const idx = lower.indexOf('comfyui/input/');
        if(idx >= 0){
          let rest = sanitized.slice(idx);
          rest = rest.replace(/^\/+/g, '');
          if(!rest.toLowerCase().startsWith('comfyui/input/')){
            rest = `comfyui/input/${rest.replace(/^comfyui\/input\//i, '')}`;
          }
          rest = `/${rest.replace(/^\/+/g, '')}`;
          rest = rest.replace(/\/{2,}/g, '/');
          const base = rest.split('/').filter(Boolean).pop();
          if(base){
            result.shortName = base;
            result.remotePath = rest;
            result.remotePathNoSlash = rest.startsWith('/') ? rest.slice(1) : rest;
            found = true;
            return true;
          }
        }

        const nameMatch = sanitized.match(/([A-Za-z0-9._-]+\.(?:png|jpe?g|webp|bmp|gif))/i);
        if(nameMatch && nameMatch[1]){
          const base = nameMatch[1];
          result.shortName = base;
          if(!result.remotePath){
            const newPath = `/comfyui/input/${base}`;
            result.remotePath = newPath;
            result.remotePathNoSlash = newPath.slice(1);
          }
          return true;
        }
        return false;
      }

      function walk(node){
        if(found || node === null || node === undefined) return;
        if(typeof node === 'string'){ applyPath(node); return; }
        if(typeof node === 'number' || typeof node === 'boolean') return;
        if(Array.isArray(node)){
          for(const item of node){ if(found) break; walk(item); }
          return;
        }
        if(typeof node === 'object'){
          if(visited.has(node)) return;
          visited.add(node);
          for(const key of Object.keys(node)){
            const val = node[key];
            if(typeof val === 'string' && applyPath(val)) return;
          }
          for(const key of Object.keys(node)){
            walk(node[key]);
            if(found) return;
          }
        }
      }

      walk(data);

      if(!result.remotePath && result.shortName){
        const path = `/comfyui/input/${result.shortName}`;
        result.remotePath = path;
        result.remotePathNoSlash = path.slice(1);
      } else if(result.remotePath && result.remotePathNoSlash === null){
        result.remotePathNoSlash = result.remotePath.startsWith('/') ? result.remotePath.slice(1) : result.remotePath;
      }

      return result;
    }

    const qs = id => document.getElementById(id);
    const el = {
      apiKey: qs('apiKey'), model: qs('model'), prompt: qs('prompt'),
      negZero: qs('negZero'), negative: qs('negative'), negWrap: qs('negWrap'),
      dims: qs('dims'), rmbg: qs('rmbg'),
      seed: qs('seed'), seedHint: qs('seedHint'), steps: qs('steps'), cfg: qs('cfg'), cfgHint: qs('cfgHint'),
      sampler: qs('sampler'), scheduler: qs('scheduler'),
      hiresToggle: qs('hiresToggle'), hiresWrap: qs('hiresWrap'), hiresScale: qs('hiresScale'), hiresSteps: qs('hiresSteps'), hiresCfg: qs('hiresCfg'), hiresCfgHint: qs('hiresCfgHint'), hiresDenoise: qs('hiresDenoise'), hiresSampler: qs('hiresSampler'), hiresScheduler: qs('hiresScheduler'), hiresSeedCustom: qs('hiresSeedCustom'), hiresSeedWrap: qs('hiresSeedWrap'), hiresSeed: qs('hiresSeed'),
      runBtn: qs('runBtn'), curlBtn: qs('curlBtn'), resetBtn: qs('resetBtn'), clearBtn: qs('clearBtn'),
      status: qs('status'), timer: qs('timer'), gallery: qs('gallery'), debugReq: qs('debugReq'), debugResp: qs('debugResp'),
    };

    const timer = makeTimer(el.timer);

    el.seedHintDefault = el.seedHint ? el.seedHint.textContent : '';

    populateSelect(el.sampler, SAMPLERS, 'euler');
    populateSelect(el.scheduler, SCHEDULERS, 'normal');
    populateSelect(el.hiresSampler, SAMPLERS, 'euler');
    populateSelect(el.hiresScheduler, SCHEDULERS, 'normal');
  
    function setCfgRangeForSampler(samplerSel, cfgInput, hintEl){
      const isCfgPP = samplerSel.value.includes('cfg_pp');
      if(isCfgPP){
        cfgInput.min = 0.5; cfgInput.max = 3.0; cfgInput.step = 0.1;
        if(+cfgInput.value < 0.5 || +cfgInput.value > 3.0) cfgInput.value = 1.0;
        hintEl.textContent = 'Range 0.5â€“3.0 (cfg_pp)';
      } else {
        cfgInput.min = 4.0; cfgInput.max = 6.0; cfgInput.step = 0.1;
        if(+cfgInput.value < 4.0 || +cfgInput.value > 6.0) cfgInput.value = 5.0;
        hintEl.textContent = 'Range 4.0â€“6.0 (non cfg_pp)';
      }
    }

    setCfgRangeForSampler(el.sampler, el.cfg, el.cfgHint);
    setCfgRangeForSampler(el.hiresSampler, el.hiresCfg, el.hiresCfgHint);

    el.sampler.addEventListener('change', () => setCfgRangeForSampler(el.sampler, el.cfg, el.cfgHint));
    el.hiresSampler.addEventListener('change', () => setCfgRangeForSampler(el.hiresSampler, el.hiresCfg, el.hiresCfgHint));

    el.negZero.addEventListener('change', () => {
      el.negWrap.style.display = el.negZero.checked ? 'none' : '';
    });

    el.hiresToggle.addEventListener('change', () => {
      el.hiresWrap.style.display = el.hiresToggle.checked ? '' : 'none';
    });

    el.hiresSeedCustom.addEventListener('change', () => {
      el.hiresSeedWrap.style.display = el.hiresSeedCustom.checked ? '' : 'none';
    });

    el.resetBtn.addEventListener('click', () => {
      // Minimal reset to spec defaults
      el.prompt.value = '';
      el.negative.value = '';
      el.negZero.checked = false; el.negWrap.style.display = '';
      el.dims.value = '1024x1024';
      el.rmbg.checked = false;
      el.seed.value = -1; el.steps.value = 25; el.cfg.value = 5.0; el.sampler.value = 'euler'; el.scheduler.value = 'normal'; setCfgRangeForSampler(el.sampler, el.cfg, el.cfgHint);
      el.hiresToggle.checked = false; el.hiresWrap.style.display = 'none'; el.hiresScale.value = 1.50; el.hiresSteps.value = 20; el.hiresCfg.value = 5.0; el.hiresDenoise.value = 0.56; el.hiresSampler.value='euler'; el.hiresScheduler.value='normal'; setCfgRangeForSampler(el.hiresSampler, el.hiresCfg, el.hiresCfgHint);
      el.hiresSeedCustom.checked = false; el.hiresSeedWrap.style.display = 'none'; el.hiresSeed.value=-1;
      if(el.seedHint) el.seedHint.textContent = el.seedHintDefault;
      el.status.textContent = 'Reset to defaults';
    });

    el.clearBtn.addEventListener('click', () => { el.gallery.innerHTML = ''; el.status.textContent = 'Gallery cleared'; });

    function getWorkflowTemplate(){
      const raw = document.getElementById('workflow-template').textContent.trim();
      return JSON.parse(raw);
    }

    function getAceTemplate(){
      const el = document.getElementById('ace-template');
      if(!el) throw new Error('ACE template missing');
      return JSON.parse(el.textContent.trim());
    }

    function deepReplacePlaceholders(obj, map){
      if (obj === null || obj === undefined) return obj;
      if (typeof obj === 'string'){
        // Replace only if the entire string is a placeholder like %name%
        const m = obj.match(/^%([a-zA-Z0-9_]+)%$/);
        if (m){
          const key = m[1];
          if (!(key in map)) throw new Error(`Missing placeholder: ${key}`);
          return map[key];
        }
        return obj;
      } else if (Array.isArray(obj)){
        return obj.map(v => deepReplacePlaceholders(v, map));
      } else if (typeof obj === 'object'){
        const out = Array.isArray(obj) ? [] : {};
        for (const k of Object.keys(obj)) out[k] = deepReplacePlaceholders(obj[k], map);
        return out;
      }
      return obj;
    }

    function buildPlaceholderMap(){
      const [w,h] = el.dims.value.split('x').map(n => parseInt(n,10));
      const negZero = !!el.negZero.checked;
      const hiresOn = !!el.hiresToggle.checked;
      let seedVal = parseInt(el.seed.value || '-1', 10);
      if(seedVal === -1){
        seedVal = genRandomSeed();
        if(el.seedHint) el.seedHint.textContent = `Random seed: ${seedVal}`;
      } else if(el.seedHint){
        el.seedHint.textContent = el.seedHintDefault;
      }
      const hiresSeed = el.hiresSeedCustom.checked ? parseInt(el.hiresSeed.value || '-1', 10) : seedVal;
      return {
        model: el.model.value,
        prompt: el.prompt.value || '',
        neg_zero_out: negZero,
        negative_prompt: negZero ? '' : (el.negative.value || ''),
        width: w, height: h,
        remove_bg: !!el.rmbg.checked,
        seed: seedVal,
        steps: parseInt(el.steps.value || '25', 10),
        cfg: parseFloat(el.cfg.value || '5.0'),
        sampler: el.sampler.value,
        scheduler: el.scheduler.value,
        use_hiresfix: hiresOn,
        hiresfix_scale_by: parseFloat(el.hiresScale.value || '1.50'),
        hiresfix_seed: hiresSeed,
        hiresfix_steps: parseInt(el.hiresSteps.value || '20', 10),
        hiresfix_cfg: parseFloat(el.hiresCfg.value || '5.0'),
        hiresfix_sampler: el.hiresSampler.value,
        hiresfix_scheduler: el.hiresScheduler.value,
        hiresfix_denoise: parseFloat(el.hiresDenoise.value || '0.56'),
      };
    }

    function buildPayload(){
      const template = getWorkflowTemplate();
      const map = buildPlaceholderMap();
      // Map keys used in placeholders are without % per deepReplacePlaceholders
      const resolved = deepReplacePlaceholders(template, map);
      return { input: { workflow: resolved } };
    }

    function makeCurl(payload){
      const key = el.apiKey.value.trim() || '<api_key>';
      return [
        'curl -sX POST',
        `  -H "Authorization: Bearer ${key}"`,
        '  -H "Content-Type: application/json"',
        `  -d '${JSON.stringify(payload)}'`,
        `  ${ENDPOINT}`
      ].join(' \n');
    }

    async function pollStatus(key, id, debugEl, statusEndpoint = STATUS_ENDPOINT){
      let attempt = 0;
      while(true){
        attempt++;
        const resp = await fetch(`${statusEndpoint}/${id}`, {
          headers: { 'Authorization': `Bearer ${key}` }
        });
        const data = await resp.json();
        if(debugEl) debugEl.textContent = JSON.stringify(data, null, 2);
        if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
        if(data.status === 'COMPLETED') return data;
        if(data.status === 'FAILED' || data.status === 'CANCELLED') throw new Error(`Job status: ${data.status}`);
        const delay = Number(data.delayTime) || Math.min(1000 * attempt, 5000);
        await new Promise(r => setTimeout(r, delay));
      }
    }

    function setBusy(b){
      el.runBtn.disabled = b;
      el.status.textContent = b? 'Runningâ€¦' : 'Idle';
      if(el.timer){ b ? timer.start() : timer.stop(); }
    }

    async function run(){
      const key = el.apiKey.value.trim();
      if (!key){ el.status.textContent = 'API key required'; return; }
      try{
        setBusy(true);
        const payload = buildPayload();
        el.debugReq.textContent = JSON.stringify(payload, null, 2);
        const resp = await fetch(ENDPOINT, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${key}`, 'Content-Type':'application/json' },
          body: JSON.stringify(payload)
        });
        let data = await resp.json();
        el.debugResp.textContent = JSON.stringify(data, null, 2);

        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        if (data.status !== 'COMPLETED'){
          if(data.id){
            el.status.textContent = 'Waiting for job...';
            data = await pollStatus(key, data.id, el.debugResp);
          } else {
            throw new Error(`Job status: ${data.status}`);
          }
        }
        if (!data.output || !Array.isArray(data.output.images) || data.output.images.length === 0) throw new Error('No images in response');

        for (const item of data.output.images){
          if (item.type === 'base64' && item.data){
            const imgUrl = `data:image/avif;base64,${item.data}`;
            addShot(imgUrl, item.filename || 'image.avif');
          } else if (item.type === 's3_url' && item.data){
            addShot(item.data, item.filename || 'image.avif');
          }
        }
        el.status.textContent = `Completed in ${data.executionTime ?? '?'} ms`;
      } catch(err){
        console.error(err);
        el.status.innerHTML = `<span class="error">Error: ${err.message}</span>`;
      } finally{ setBusy(false); }
    }

    function addShot(url, name){
      const wrap = document.createElement('div');
      wrap.className = 'shot';
      const header = document.createElement('div'); header.className = 'header';
      header.innerHTML = `<header><span class="mono" title="${name}">${name}</span><a class="btn" href="${url}" download>Download</a></header>`;
      wrap.appendChild(header);
      const img = new Image(); img.loading = 'lazy'; img.src = url; img.addEventListener('click', ()=>openLightbox(url)); wrap.appendChild(img);
      el.gallery.prepend(wrap);
    }

    el.runBtn.addEventListener('click', (e)=>{ e.preventDefault(); run(); });

    el.curlBtn.addEventListener('click', ()=>{
      const payload = buildPayload();
      const text = makeCurl(payload);
      navigator.clipboard.writeText(text).then(()=>{ el.status.textContent = 'cURL copied'; });
    });

    // --- Wan 2.2 helpers ---
    const wan = id => document.getElementById(id);
    const wanel = {
      apiKey: document.getElementById('apiKey'),
      prompt: wan('wan-prompt'),
      image: wan('wan-image'),
      imageHint: wan('wan-image-hint'),
      nsfw: wan('wan-nsfw'),
      lowstep: wan('wan-lowstep'),
      negzero: wan('wan-negzero'),
      negative: wan('wan-negative'),
      negWrap: wan('wan-neg-wrap'),
      mp: wan('wan-mp'),
      length: wan('wan-length'),
      steps: wan('wan-steps'),
      stepsHint: wan('wan-steps-hint'),
      cfgWrap: wan('wan-cfg-wrap'),
      cfg: wan('wan-cfg'),
      cfgNote: wan('wan-cfg-note'),
      sampler: wan('wan-sampler'),
      scheduler: wan('wan-scheduler'),
      interp: wan('wan-interp'),
      runBtn: wan('wan-run'),
      curlBtn: wan('wan-curl'),
      resetBtn: wan('wan-reset'),
      clearBtn: wan('wan-clear'),
      status: wan('wan-status'),
      timer: wan('wan-timer'),
      gallery: wan('wan-gallery'),
      debugReq: wan('wan-debugReq'),
      debugResp: wan('wan-debugResp'),
    };

    const wanTimer = makeTimer(wanel.timer);
    const wanState = { blobCleanups: [], lastUpload: null };

    if(wanel.sampler) populateSelect(wanel.sampler, SAMPLERS, 'euler');
    if(wanel.scheduler) populateSelect(wanel.scheduler, SCHEDULERS, 'simple');

    function sanitizeWanMp(){
      if(!wanel.mp) return 1.0;
      let val = parseFloat(wanel.mp.value || '1');
      if(!Number.isFinite(val)) val = 1;
      if(val < 0.5) val = 0.5;
      if(val > 1.0) val = 1.0;
      val = Math.round(val * 100) / 100;
      wanel.mp.value = val.toFixed(2);
      return val;
    }

    function sanitizeWanLength(){
      if(!wanel.length) return 49;
      let val = parseInt(wanel.length.value || '49', 10);
      if(!Number.isFinite(val)) val = 49;
      if(val < 33) val = 33;
      if(val > 81) val = 81;
      wanel.length.value = val;
      return val;
    }

    function sanitizeWanCfg(){
      if(!wanel.cfg) return 3.5;
      let val = parseFloat(wanel.cfg.value || '3.5');
      if(!Number.isFinite(val)) val = 3.5;
      if(val < 1.0) val = 1.0;
      if(val > 7.0) val = 7.0;
      val = Math.round(val * 10) / 10;
      wanel.cfg.value = val.toFixed(1);
      return val;
    }

    function sanitizeWanSteps(){
      if(!wanel.steps) return 16;
      const low = !!(wanel.lowstep && wanel.lowstep.checked);
      const min = low ? 4 : 10;
      const max = low ? 8 : 25;
      let val = parseInt(wanel.steps.value || (low ? '4' : '16'), 10);
      if(!Number.isFinite(val)) val = low ? 4 : 16;
      if(val < min) val = min;
      if(val > max) val = max;
      if(val % 2 !== 0){
        val = Math.min(max, val + 1);
        if(val % 2 !== 0) val = Math.max(min, val - 1);
        if(val % 2 !== 0) val = min;
      }
      wanel.steps.min = min;
      wanel.steps.max = max;
      wanel.steps.step = 2;
      wanel.steps.value = val;
      if(wanel.stepsHint){
        wanel.stepsHint.textContent = low ? 'Range 4â€“8 (even numbers)' : 'Range 10â€“25 (even numbers)';
      }
      return val;
    }

    function updateWanVisibility(){
      const low = !!(wanel.lowstep && wanel.lowstep.checked);
      const zero = !!(wanel.negzero && wanel.negzero.checked);
      if(wanel.negWrap) wanel.negWrap.style.display = (!low && !zero) ? '' : 'none';
      if(wanel.cfgWrap) wanel.cfgWrap.style.display = low ? 'none' : '';
      if(wanel.cfgNote) wanel.cfgNote.style.display = low ? '' : 'none';
      sanitizeWanSteps();
      if(!low) sanitizeWanCfg();
    }

    function clearWanOutputs(){
      if(wanel.gallery) wanel.gallery.innerHTML = '';
      while(wanState.blobCleanups.length){
        const fn = wanState.blobCleanups.pop();
        try{ if(typeof fn === 'function') fn(); } catch(err){ console.debug('WAN cleanup error', err); }
      }
    }

    function setWanBusy(b){
      if(wanel.runBtn) wanel.runBtn.disabled = b;
      if(wanel.timer){ b ? wanTimer.start() : wanTimer.stop(); }
    }

    function getWanTemplate(){
      const el = document.getElementById('wan-template');
      if(!el) throw new Error('Missing wan-template');
      return JSON.parse(el.textContent.trim());
    }

    function buildWanPlaceholderMap(uploadInfo){
      if(!uploadInfo || !uploadInfo.shortName) throw new Error('Missing uploaded filename');
      const low = !!(wanel.lowstep && wanel.lowstep.checked);
      const zero = !!(wanel.negzero && wanel.negzero.checked);
      const nsfw = !!(wanel.nsfw && wanel.nsfw.checked);
      const steps = sanitizeWanSteps();
      const mpVal = sanitizeWanMp();
      const lengthVal = sanitizeWanLength();
      let cfgVal = 1.0;
      if(!low) cfgVal = sanitizeWanCfg();
      const cfgOut = low ? 1.0 : Math.round(cfgVal * 100) / 100;
      const negative = (!low && !zero && wanel.negative) ? (wanel.negative.value || '') : '';
      return {
        prompt: wanel.prompt ? wanel.prompt.value || '' : '',
        negative_prompt: negative,
        is_nsfw: nsfw,
        low_step: low,
        zero_out_negative: zero,
        steps,
        cfg: cfgOut,
        sampler: wanel.sampler ? wanel.sampler.value : 'euler',
        scheduler: wanel.scheduler ? wanel.scheduler.value : 'simple',
        img: uploadInfo.shortName,
        mp: Math.round(mpVal * 100) / 100,
        length: lengthVal,
        interpolate: !!(wanel.interp && wanel.interp.checked)
      };
    }

    function buildWanPayload(uploadInfo){
      const template = getWanTemplate();
      const map = buildWanPlaceholderMap(uploadInfo);
      const resolved = deepReplacePlaceholders(template, map);
      return { input: { workflow: resolved } };
    }

    async function uploadWanImage(file, key){
      const info = await readFileAsBase64(file);
      const filename = generateWanFilename(info.extension);
      const packet = createWanUploadPacket(filename, info);
      const headers = { 'Authorization': `Bearer ${key}`, 'Content-Type': 'application/json' };
      const bodyString = JSON.stringify(packet.body);
      let responseData = null;
      try{
        const resp = await fetch(WAN_RUN_ENDPOINT, { method: 'POST', headers, body: bodyString });
        const text = await resp.text();
        if(text){
          try{ responseData = JSON.parse(text); }
          catch(err){ responseData = null; }
        }
        if(!resp.ok){
          let message = null;
          const errSource = responseData && typeof responseData === 'object' ? responseData : null;
          if(errSource){
            const errObj = errSource.error && typeof errSource.error === 'object' ? errSource.error : null;
            if(errObj){
              message = errObj.message || errObj.msg || errObj.detail || null;
            }
            if(!message && typeof errSource.error === 'string') message = errSource.error;
            if(!message) message = errSource.message || errSource.detail || null;
          }
          if(message && typeof message !== 'string') message = JSON.stringify(message);
          throw new Error(message ? `HTTP ${resp.status}: ${message}` : `HTTP ${resp.status}`);
        }
      } catch(err){
        throw new Error(`Upload request failed: ${err.message}`);
      }

      if(!responseData || typeof responseData !== 'object'){
        throw new Error('Unexpected upload response');
      }

      const jobId = responseData.id || responseData.jobId || responseData.job_id || null;
      let finalData = responseData;
      if(responseData.status && responseData.status !== 'COMPLETED'){
        if(jobId){
          if(wanel.status) wanel.status.textContent = 'Waiting for upload jobâ€¦';
          try{
            finalData = await pollStatus(key, jobId, null, WAN_STATUS_ENDPOINT);
          } catch(err){
            throw new Error(`Upload status error: ${err.message}`);
          }
        } else {
          throw new Error(`Upload job status: ${responseData.status}`);
        }
      }

      const parsed = parseWanUploadResult(finalData, filename, packet.remotePath);
      const remotePath = parsed.remotePath || packet.remotePath;
      const remotePathNoSlash = parsed.remotePathNoSlash || (remotePath ? (remotePath.startsWith('/') ? remotePath.slice(1) : remotePath) : null);
      const shortName = parsed.shortName || filename;

      return {
        shortName,
        remotePath,
        remotePathNoSlash,
        packet,
        base64: info.base64,
        mime: info.mime,
        dataUrl: info.dataUrl,
        endpoint: WAN_RUN_ENDPOINT,
        requestBody: packet.body,
        jobId,
        response: finalData
      };
    }


  function guessWanFilenameFromUrl(url){
    try{
      const u = new URL(url);
      const parts = u.pathname.split('/').filter(Boolean);
      const name = parts.pop();
      if(name) return name;
    }catch(err){
      if(typeof url === 'string'){
        const tail = url.split('/').filter(Boolean).pop();
        if(tail) return tail;
      }
    }
    return 'video.mp4';
  }

  function guessWanFilenameFromDataUri(uri){
    const match = /^data:video\/([^;,]+)/i.exec(uri || '');
    if(match && match[1]){
      const ext = match[1].split('/').pop();
      if(ext) return `video.${ext}`;
    }
    return 'video.mp4';
  }

  function wanItemToVideoSource(item){
    const videoPattern = /\.(?:mp4|webm|mov|mkv|avi|gif|gifv|mpg|mpeg)$/i;
    if(item === null || item === undefined) return null;
    if(typeof item === 'string'){
      const trimmed = item.trim();
      if(!trimmed) return null;
      if(trimmed.startsWith('data:video/')){
        return { kind: 'data', url: trimmed, filename: guessWanFilenameFromDataUri(trimmed) };
      }
      if(/^https?:/i.test(trimmed) && videoPattern.test(trimmed)){
        return { kind: 'url', url: trimmed, filename: guessWanFilenameFromUrl(trimmed) };
      }
      return null;
    }
    if(Array.isArray(item)){
      for(const entry of item){
        const found = wanItemToVideoSource(entry);
        if(found) return found;
      }
      return null;
    }
    if(typeof item !== 'object') return null;

    const filename = item.filename || item.file_name || item.name || item.originalName || item.original_filename || null;
    const typeRaw = item.type || item.kind || item.format || '';
    const lowerType = typeof typeRaw === 'string' ? typeRaw.toLowerCase() : '';
    const mimeRaw = item.mime || item.mimetype || item.content_type || item.contentType || '';
    const lowerMime = typeof mimeRaw === 'string' ? mimeRaw.toLowerCase() : '';

    if(lowerType === 'base64' && typeof item.data === 'string'){
      const mime = lowerMime || 'video/mp4';
      return { kind: 'data', url: `data:${mime};base64,${item.data}`, filename: filename || guessWanFilenameFromDataUri(`data:${mime}`) };
    }

    if(item.data && typeof item.data === 'string'){
      const trimmed = item.data.trim();
      if(trimmed.startsWith('data:video/')){
        return { kind: 'data', url: trimmed, filename: filename || guessWanFilenameFromDataUri(trimmed) };
      }
      if(/^https?:/i.test(trimmed) && (videoPattern.test(trimmed) || lowerType.includes('video') || lowerMime.startsWith('video'))){
        return { kind: 'url', url: trimmed, filename: filename || guessWanFilenameFromUrl(trimmed) };
      }
    }

    const candidateKeys = ['url', 'signed_url', 'signedUrl', 'downloadUrl', 'download_url', 'path', 'location', 'uri'];
    for(const key of candidateKeys){
      const value = item[key];
      if(typeof value !== 'string') continue;
      const trimmed = value.trim();
      if(!trimmed) continue;
      if(trimmed.startsWith('data:video/')){
        return { kind: 'data', url: trimmed, filename: filename || guessWanFilenameFromDataUri(trimmed) };
      }
      if(/^https?:/i.test(trimmed) && (videoPattern.test(trimmed) || lowerType.includes('video') || lowerMime.startsWith('video'))){
        return { kind: 'url', url: trimmed, filename: filename || guessWanFilenameFromUrl(trimmed) };
      }
    }

    if(item.bucket && item.key && typeof item.bucket === 'string' && typeof item.key === 'string'){
      const key = item.key.startsWith('/') ? item.key.slice(1) : item.key;
      const s3Url = item.key.startsWith('http') ? item.key : `https://${item.bucket}.s3.amazonaws.com/${key}`;
      if(/^https?:/i.test(s3Url)){
        return { kind: 'url', url: s3Url, filename: filename || guessWanFilenameFromUrl(s3Url) };
      }
    }

    if(item.data && typeof item.data === 'object'){
      const nested = wanItemToVideoSource(item.data);
      if(nested) return nested;
    }
    if(item.output && typeof item.output === 'object'){
      const nested = wanItemToVideoSource(item.output);
      if(nested) return nested;
    }
    if(item.result && typeof item.result === 'object'){
      const nested = wanItemToVideoSource(item.result);
      if(nested) return nested;
    }

    let fileId = item.fileId || item.file_id || null;
    const hasExplicitUrl = candidateKeys.some(key => typeof item[key] === 'string' && item[key].trim().startsWith('http'));
    if(!fileId && item.id && (lowerType === 'file' || lowerType === 'output' || (!hasExplicitUrl && (filename || lowerType.includes('video') || lowerMime.startsWith('video'))))){
      fileId = item.id;
    }
    if(fileId){
      const inferredName = filename || item.name || guessWanFilenameFromUrl(item.path || item.key || '') || 'video.mp4';
      return { kind: 'file', fileId, filename: inferredName };
    }

    return null;
  }

  function extractWanVideos(data){
    const ready = [];
    const pending = [];
    const seenUrls = new Set();
    const seenFiles = new Set();
    const visited = new WeakSet();

    function pushSource(src){
      if(!src) return;
      if(src.kind === 'file'){
        const fid = src.fileId;
        if(fid && !seenFiles.has(fid)){
          seenFiles.add(fid);
          pending.push({ fileId: fid, filename: src.filename || 'video.mp4' });
        }
        return;
      }
      const url = src.url;
      if(!url || seenUrls.has(url)) return;
      seenUrls.add(url);
      const name = src.filename || (src.kind === 'data' ? guessWanFilenameFromDataUri(url) : guessWanFilenameFromUrl(url));
      const entry = { url, filename: name };
      if(typeof src.cleanup === 'function') entry.cleanup = src.cleanup;
      ready.push(entry);
    }

    function walk(node){
      if(node === null || node === undefined) return;
      if(typeof node === 'string'){
        const trimmed = node.trim();
        if(!trimmed) return;
        pushSource(wanItemToVideoSource(trimmed));
        return;
      }
      if(typeof node === 'number' || typeof node === 'boolean') return;
      if(Array.isArray(node)){
        for(const item of node) walk(item);
        return;
      }
      if(typeof node === 'object'){
        if(visited.has(node)) return;
        visited.add(node);
        pushSource(wanItemToVideoSource(node));
        for(const key of Object.keys(node)){
          if(key === 'id' || key === 'status' || key === 'executionTime' || key === 'delayTime' || key === 'workerId') continue;
          walk(node[key]);
        }
      }
    }

    walk(data);
    return { ready, pending };
  }

  async function downloadWanFile(key, jobId, fileId, fallbackName = 'video.mp4'){
    if(!fileId) return null;
    const headers = { 'Authorization': `Bearer ${key}` };
    const bases = new Set();
    bases.add(`${WAN_FILE_ENDPOINT}/${fileId}`);
    bases.add(`${WAN_FILES_ENDPOINT}/${fileId}`);
    bases.add(`${WAN_BASE_ENDPOINT}/output/${fileId}`);
    if(jobId){
      bases.add(`${WAN_RUNS_ENDPOINT}/${jobId}/output/${fileId}`);
      bases.add(`${WAN_RUNS_ENDPOINT}/${jobId}/file/${fileId}`);
      bases.add(`${WAN_RUN_ENDPOINT}/${jobId}/output/${fileId}`);
      bases.add(`${WAN_ENDPOINT}/${jobId}/output/${fileId}`);
      bases.add(`${WAN_ENDPOINT}/${jobId}/file/${fileId}`);
    }
    const queries = ['', '?download=1', '?rp_download=1', '?rp_download=true'];
    const variants = new Set();
    for(const base of bases){
      variants.add(base);
      variants.add(`${base}/download`);
    }
    for(const base of variants){
      for(const query of queries){
        const target = `${base}${query}`;
        try{
          const resp = await fetch(target, { headers });
          if(!resp.ok) continue;
          let json = null;
          try{
            const text = await resp.clone().text();
            if(text && text.trim().startsWith('{')){
              json = JSON.parse(text);
            }
          } catch(err){ json = null; }
          if(json){
            const src = wanItemToVideoSource(json);
            if(src && src.kind !== 'file'){
              return { url: src.url, filename: src.filename || fallbackName, cleanup: src.cleanup };
            }
            continue;
          }
          const blob = await resp.blob();
          const name = parseContentDispositionFilename(resp.headers.get('content-disposition')) || fallbackName;
          const blobUrl = URL.createObjectURL(blob);
          return { url: blobUrl, filename: name, cleanup: () => URL.revokeObjectURL(blobUrl) };
        } catch(err){
          console.debug('WAN download candidate failed', target, err);
        }
      }
    }
    return null;
  }
    function addWanVideo(entry){
      if(!wanel.gallery) return;
      const wrap = document.createElement('div');
      wrap.className = 'shot';
      const header = document.createElement('div');
      header.className = 'header';
      const headerInner = document.createElement('header');
      const name = entry.filename || 'video.mp4';
      const title = document.createElement('span');
      title.className = 'mono';
      title.textContent = name;
      title.title = name;
      const link = document.createElement('a');
      link.className = 'btn';
      link.href = entry.url;
      link.download = name;
      link.textContent = 'Download';
      headerInner.appendChild(title);
      headerInner.appendChild(link);
      header.appendChild(headerInner);
      wrap.appendChild(header);
      const video = document.createElement('video');
      video.controls = true;
      video.preload = 'metadata';
      video.loop = true;
      video.muted = true;
      video.playsInline = true;
      video.style.width = '100%';
      video.src = entry.url;
      wrap.appendChild(video);
      if(entry.cleanup && typeof entry.cleanup === 'function') wanState.blobCleanups.push(entry.cleanup);
      wanel.gallery.prepend(wrap);
    }

    function makeWanCurl(uploadDetails, payload){
      const key = (wanel.apiKey && wanel.apiKey.value || '').trim() || '<api_key>';
      const uploadEndpoint = uploadDetails && uploadDetails.endpoint ? uploadDetails.endpoint : WAN_RUN_ENDPOINT;
      const uploadBody = uploadDetails && uploadDetails.requestBody ? uploadDetails.requestBody : null;
      const segments = [];
      if(uploadBody){
        segments.push([
          '# Upload image to /comfyui/input',
          'curl -sX POST',
          `  -H "Authorization: Bearer ${key}"`,
          '  -H "Content-Type: application/json"',
          `  -d '${JSON.stringify(uploadBody)}'`,
          `  ${uploadEndpoint}`
        ].join(' \n'));
      }
      segments.push([
        '# Start workflow',
        'curl -sX POST',
        `  -H "Authorization: Bearer ${key}"`,
        '  -H "Content-Type: application/json"',
        `  -d '${JSON.stringify(payload)}'`,
        `  ${WAN_ENDPOINT}`
      ].join(' \n'));
      return segments.join('\n\n');
    }

    async function runWan(){
      const key = (wanel.apiKey && wanel.apiKey.value || '').trim();
      if(!key){ if(wanel.status) wanel.status.textContent = 'API key required'; return; }
      const file = wanel.image && wanel.image.files && wanel.image.files[0];
      if(!file){ if(wanel.status) wanel.status.textContent = 'Select an image first'; return; }
      try{
        setWanBusy(true);
        if(wanel.status) wanel.status.textContent = 'Uploading imageâ€¦';
        const uploadInfo = await uploadWanImage(file, key);
        wanState.lastUpload = uploadInfo;
        if(wanel.status) wanel.status.textContent = 'Runningâ€¦';
        const payload = buildWanPayload({ shortName: uploadInfo.shortName });
        if(wanel.debugReq) wanel.debugReq.textContent = JSON.stringify(payload, null, 2);
        const resp = await fetch(WAN_ENDPOINT, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${key}`, 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        let data = await resp.json();
        let jobId = data && data.id ? data.id : null;
        if(wanel.debugResp) wanel.debugResp.textContent = JSON.stringify(data, null, 2);
        if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
        if(data.status !== 'COMPLETED'){
          if(data.id){
            if(wanel.status) wanel.status.textContent = 'Waiting for job...';
            data = await pollStatus(key, data.id, wanel.debugResp, WAN_STATUS_ENDPOINT);
            if(data && data.id) jobId = data.id;
          } else {
            throw new Error(`Job status: ${data.status}`);
          }
        }
        const { ready, pending } = extractWanVideos(data);
        const videos = [...ready];
        if(pending.length && wanel.status) wanel.status.textContent = 'Fetching video filesâ€¦';
        for(const item of pending){
          const downloaded = await downloadWanFile(key, jobId, item.fileId, item.filename);
          if(downloaded) videos.push(downloaded);
        }
        if(!videos.length) throw new Error('No video returned');
        for(const entry of videos){
          addWanVideo(entry);
        }
        if(wanel.status) wanel.status.textContent = `Completed in ${data.executionTime ?? '?'} ms`;
      } catch(err){
        console.error(err);
        if(wanel.status) wanel.status.innerHTML = `<span class="error">Error: ${err.message}</span>`;
      } finally { setWanBusy(false); }
    }

    if(wanel.lowstep) wanel.lowstep.addEventListener('change', updateWanVisibility);
    if(wanel.negzero) wanel.negzero.addEventListener('change', updateWanVisibility);
    if(wanel.steps) wanel.steps.addEventListener('change', sanitizeWanSteps);
    if(wanel.cfg) wanel.cfg.addEventListener('change', sanitizeWanCfg);
    if(wanel.mp) wanel.mp.addEventListener('change', sanitizeWanMp);
    if(wanel.length) wanel.length.addEventListener('change', sanitizeWanLength);
    if(wanel.image) wanel.image.addEventListener('change', () => {
      const file = wanel.image && wanel.image.files && wanel.image.files[0];
      if(file){
        const size = formatBytes(file.size);
        if(wanel.imageHint) wanel.imageHint.textContent = size ? `${file.name} (${size})` : file.name;
      } else if(wanel.imageHint){
        wanel.imageHint.textContent = 'Select a PNG/JPG/WebP. It will be uploaded to /comfyui/input with a random filename.';
      }
      wanState.lastUpload = null;
    });

    if(wanel.runBtn) wanel.runBtn.addEventListener('click', (e)=>{ e.preventDefault(); runWan(); });

    if(wanel.curlBtn) wanel.curlBtn.addEventListener('click', async ()=>{
      const file = wanel.image && wanel.image.files && wanel.image.files[0];
      if(!file && !wanState.lastUpload){ if(wanel.status) wanel.status.textContent = 'Select an image first'; return; }
      try{
        let uploadDetails = wanState.lastUpload ? { endpoint: wanState.lastUpload.endpoint, requestBody: wanState.lastUpload.requestBody } : null;
        let placeholderInfo = wanState.lastUpload ? { shortName: wanState.lastUpload.shortName } : null;
        if(!uploadDetails){
          const info = await readFileAsBase64(file);
          const filename = generateWanFilename(info.extension);
          const packet = createWanUploadPacket(filename, info);
          uploadDetails = { endpoint: WAN_FILES_ENDPOINT, requestBody: packet.body };
          placeholderInfo = { shortName: filename };
        }
        const payload = buildWanPayload(placeholderInfo);
        const text = makeWanCurl(uploadDetails, payload);
        if(navigator.clipboard && navigator.clipboard.writeText){
          await navigator.clipboard.writeText(text);
          if(wanel.status) wanel.status.textContent = 'cURL copied';
        }
      } catch(err){
        console.error(err);
        if(wanel.status) wanel.status.innerHTML = `<span class="error">Error: ${err.message}</span>`;
      }
    });

    if(wanel.resetBtn) wanel.resetBtn.addEventListener('click', ()=>{
      if(wanel.prompt) wanel.prompt.value = '';
      if(wanel.negative) wanel.negative.value = '';
      if(wanel.nsfw) wanel.nsfw.checked = false;
      if(wanel.lowstep) wanel.lowstep.checked = false;
      if(wanel.negzero) wanel.negzero.checked = false;
      if(wanel.interp) wanel.interp.checked = true;
      if(wanel.image) wanel.image.value = '';
      if(wanel.imageHint) wanel.imageHint.textContent = 'Select a PNG/JPG/WebP. It will be uploaded to /comfyui/input with a random filename.';
      if(wanel.mp) wanel.mp.value = '1.00';
      if(wanel.length) wanel.length.value = 49;
      if(wanel.steps) wanel.steps.value = 16;
      if(wanel.cfg) wanel.cfg.value = 3.5;
      if(wanel.sampler) wanel.sampler.value = 'euler';
      if(wanel.scheduler) wanel.scheduler.value = 'simple';
      wanState.lastUpload = null;
      updateWanVisibility();
      sanitizeWanMp();
      sanitizeWanLength();
      sanitizeWanSteps();
      if(wanel.status) wanel.status.textContent = 'Reset to defaults';
    });

    if(wanel.clearBtn) wanel.clearBtn.addEventListener('click', ()=>{
      clearWanOutputs();
      if(wanel.status) wanel.status.textContent = 'Outputs cleared';
    });

    // Initialize Wan defaults
    sanitizeWanMp();
    sanitizeWanLength();
    sanitizeWanSteps();
    updateWanVisibility();

    // --- ACE-Step helpers ---
    const ace = id => document.getElementById(id);
    const acel = {
      apiKey: document.getElementById('apiKey'),
      tags: ace('ace-tags'),
      structure: ace('ace-structure'),
      minutes: ace('ace-minutes'),
      seconds: ace('ace-seconds'),
      seed: ace('ace-seed'), seedHint: ace('ace-seedHint'),
      steps: ace('ace-steps'), cfg: ace('ace-cfg'),
      sampler: ace('ace-sampler'), scheduler: ace('ace-scheduler'),
      quality: ace('ace-quality'),
      runBtn: ace('ace-run'), curlBtn: ace('ace-curl'), resetBtn: ace('ace-reset'), clearBtn: ace('ace-clear'),
      status: ace('ace-status'), timer: ace('ace-timer'), gallery: ace('ace-gallery'),
      debugReq: ace('ace-debugReq'), debugResp: ace('ace-debugResp'),
    };

    const acetimer = makeTimer(acel.timer);
    const aceBlobCleanups = [];

    if(acel.sampler) populateSelect(acel.sampler, SAMPLERS, 'res_multistep');
    if(acel.scheduler) populateSelect(acel.scheduler, SCHEDULERS, 'linear_quadratic');

    acel.seedHintDefault = acel.seedHint ? acel.seedHint.textContent : '';

    function clampSeconds(val){
      let s = parseFloat(val);
      if(!Number.isFinite(s)) s = 0;
      if(s < 0) s = 0;
      if(s > 59.999) s = 59.999;
      return s;
    }

    function parseAceDurationToSeconds(value){
      if(value === null || value === undefined) return null;
      if(typeof value === 'number'){ return Number.isFinite(value) && value > 0 ? value : null; }
      if(typeof value !== 'string') return null;
      const trimmed = value.trim();
      if(!trimmed) return null;
      if(/^\d+(?:\.\d+)?$/.test(trimmed)){ return parseFloat(trimmed); }
      const colonParts = trimmed.split(':');
      if(colonParts.length > 1){
        let total = 0;
        let multiplier = 1;
        while(colonParts.length){
          const part = colonParts.pop();
          if(part === undefined) break;
          const num = parseFloat(part);
          if(!Number.isFinite(num)) return null;
          total += num * multiplier;
          multiplier *= 60;
        }
        return total > 0 ? total : null;
      }
      const unitMatch = trimmed.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|sec|secs|seconds|m|min|minutes|h|hr|hrs|hours)$/i);
      if(unitMatch){
        const magnitude = parseFloat(unitMatch[1]);
        if(!Number.isFinite(magnitude) || magnitude <= 0) return null;
        const unit = unitMatch[2].toLowerCase();
        if(unit === 'ms') return magnitude / 1000;
        if(unit === 's' || unit === 'sec' || unit === 'secs' || unit === 'seconds') return magnitude;
        if(unit === 'm' || unit === 'min' || unit === 'minutes') return magnitude * 60;
        if(unit === 'h' || unit === 'hr' || unit === 'hrs' || unit === 'hours') return magnitude * 3600;
      }
      const simpleMatch = trimmed.match(/^([0-9]+)m(?:\s*([0-9]+(?:\.[0-9]+)?)s)?$/i);
      if(simpleMatch){
        const minutes = parseFloat(simpleMatch[1]);
        const seconds = simpleMatch[2] ? parseFloat(simpleMatch[2]) : 0;
        if(Number.isFinite(minutes) && minutes >= 0 && Number.isFinite(seconds) && seconds >= 0){
          const total = minutes * 60 + seconds;
          return total > 0 ? total : null;
        }
      }
      return null;
    }

    function findAceDurationSeconds(obj, visited = new WeakSet()){
      if(!obj || typeof obj !== 'object') return null;
      if(visited.has(obj)) return null;
      visited.add(obj);
      const candidateKeys = [
        'duration', 'durationSeconds', 'duration_seconds', 'duration_sec', 'seconds', 'secs',
        'length', 'length_seconds', 'lengthSeconds', 'audio_seconds', 'audioSeconds',
        'total_seconds', 'time_seconds', 'time'
      ];
      for(const key of candidateKeys){
        if(Object.prototype.hasOwnProperty.call(obj, key)){
          const parsed = parseAceDurationToSeconds(obj[key]);
          if(parsed) return parsed;
        }
      }
      const nestedKeys = ['metadata', 'meta', 'info', 'details', 'extra', 'attributes', 'audioInfo', 'audio_info'];
      for(const key of nestedKeys){
        if(!Object.prototype.hasOwnProperty.call(obj, key)) continue;
        const value = obj[key];
        if(Array.isArray(value)){
          for(const item of value){
            const found = findAceDurationSeconds(item, visited);
            if(found) return found;
          }
        } else if(value && typeof value === 'object'){
          const found = findAceDurationSeconds(value, visited);
          if(found) return found;
        }
      }
      return null;
    }

    function formatAceClock(seconds){
      if(!Number.isFinite(seconds) || seconds <= 0) return null;
      const totalSeconds = Math.floor(seconds);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const secs = totalSeconds % 60;
      const secStr = String(secs).padStart(2, '0');
      if(hours > 0){
        return `${hours}:${String(minutes).padStart(2, '0')}:${secStr}`;
      }
      return `${minutes}:${secStr}`;
    }

    function formatAceSecondsValue(seconds){
      if(!Number.isFinite(seconds) || seconds <= 0) return null;
      let decimals = 0;
      if(seconds < 10) decimals = 2;
      else if(seconds < 100) decimals = 1;
      let str = seconds.toFixed(decimals);
      if(decimals > 0) str = str.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
      return str;
    }

    function formatAceDurationLabel(seconds){
      if(!Number.isFinite(seconds) || seconds <= 0) return null;
      const clock = formatAceClock(seconds);
      const precise = formatAceSecondsValue(seconds);
      if(clock && precise) return `Length: ${clock} (${precise}s)`;
      if(clock) return `Length: ${clock}`;
      if(precise) return `Length: ${precise}s`;
      return null;
    }

    function guessAceFilenameFromUrl(url){
      try{
        const u = new URL(url);
        const parts = u.pathname.split('/').filter(Boolean);
        const name = parts.pop();
        if(name) return name;
      }catch(err){
        if(typeof url === 'string'){
          const tail = url.split('/').filter(Boolean).pop();
          if(tail) return tail;
        }
      }
      return 'audio.ogg';
    }

    function guessAceFilenameFromDataUri(uri){
      const match = /^data:audio\/([^;,]+)/i.exec(uri || '');
      if(match && match[1]){
        const ext = match[1].split('/').pop();
        if(ext) return `audio.${ext}`;
      }
      return 'audio.ogg';
    }

    function finalizeAceSource(src, context, fallbackDuration){
      if(!src) return src;
      let duration = null;
      if(Number.isFinite(fallbackDuration) && fallbackDuration > 0){
        duration = fallbackDuration;
      } else if(typeof context === 'number'){
        duration = context;
      } else if(context && typeof context === 'object'){
        duration = findAceDurationSeconds(context);
      }
      if(Number.isFinite(duration) && duration > 0) src.duration = duration;
      return src;
    }

    function parseContentDispositionFilename(header){
      if(!header) return null;
      const star = header.match(/filename\*=UTF-8''([^;]+)/i);
      if(star && star[1]){
        try{ return decodeURIComponent(star[1]); }
        catch(err){ return star[1]; }
      }
      const quoted = header.match(/filename="?([^";]+)"?/i);
      if(quoted && quoted[1]) return quoted[1];
      return null;
    }

    if(acel.seconds){
      acel.seconds.addEventListener('change', ()=>{
        const s = clampSeconds(acel.seconds.value || '0');
        acel.seconds.value = Number.isInteger(s) ? String(Math.trunc(s)) : s.toFixed(3);
      });
    }

    if(acel.minutes){
      acel.minutes.addEventListener('change', ()=>{
        let m = parseInt(acel.minutes.value || '0', 10);
        if(!Number.isFinite(m) || m < 0) m = 0;
        acel.minutes.value = m;
      });
    }

    function getAceLengthSeconds(){
      const minutes = Math.max(0, parseInt(acel.minutes && acel.minutes.value || '0', 10) || 0);
      const seconds = clampSeconds(acel.seconds && acel.seconds.value || '0');
      return Math.round((minutes * 60 + seconds) * 1000) / 1000;
    }

    function buildAcePlaceholderMap(){
      let seedVal = parseInt(acel.seed && acel.seed.value || '-1', 10);
      if(!Number.isFinite(seedVal)) seedVal = -1;
      if(seedVal === -1){
        seedVal = genRandomSeed();
        if(acel.seedHint) acel.seedHint.textContent = `Random seed: ${seedVal}`;
      } else if(acel.seedHint){
        acel.seedHint.textContent = acel.seedHintDefault;
      }
      const rawSteps = parseInt(acel.steps && (acel.steps.value || '50'), 10);
      const stepsVal = Number.isFinite(rawSteps) ? Math.min(75, Math.max(25, rawSteps)) : 50;
      const rawCfg = parseFloat(acel.cfg && (acel.cfg.value || '5.0'));
      const cfgVal = Number.isFinite(rawCfg) ? Math.max(1.0, rawCfg) : 5.0;
      return {
        tags: acel.tags && acel.tags.value || '',
        structure: acel.structure && acel.structure.value || '',
        length: getAceLengthSeconds(),
        seed: seedVal,
        steps: stepsVal,
        cfg: Number.isFinite(cfgVal) ? cfgVal : 5.0,
        sampler: acel.sampler && acel.sampler.value || 'res_multistep',
        scheduler: acel.scheduler && acel.scheduler.value || 'linear_quadratic',
        quality: acel.quality && acel.quality.value || '128k',
      };
    }

    function buildAcePayload(){
      const template = getAceTemplate();
      const map = buildAcePlaceholderMap();
      const resolved = deepReplacePlaceholders(template, map);
      return { input: { workflow: resolved } };
    }

    function makeAceCurl(payload){
      const key = (acel.apiKey && acel.apiKey.value || '').trim() || '<api_key>';
      return [
        'curl -sX POST',
        `  -H "Authorization: Bearer ${key}"`,
        '  -H "Content-Type: application/json"',
        `  -d '${JSON.stringify(payload)}'`,
        `  ${ACE_ENDPOINT}`
      ].join(' \n');
    }

    function setAceBusy(b){
      if(acel.runBtn) acel.runBtn.disabled = b;
      if(acel.status){
        if(b){
          acel.status.textContent = 'Runningâ€¦';
        } else if(acel.status.textContent === 'Runningâ€¦' || acel.status.textContent === 'Fetching audio filesâ€¦'){
          acel.status.textContent = 'Idle';
        }
      }
      if(acel.timer){ b ? acetimer.start() : acetimer.stop(); }
    }

    function aceItemToSource(item){
      if(!item) return null;
      const audioPattern = /\.(?:ogg|opus|wav|mp3|m4a|flac)(?:\?.*)?$/i;
      if(typeof item === 'string'){
        const trimmed = item.trim();
        if(trimmed.startsWith('data:audio/')){
          return { kind: 'data', url: trimmed, filename: guessAceFilenameFromDataUri(trimmed) };
        }
        if(/^https?:/i.test(trimmed) && audioPattern.test(trimmed)){
          return { kind: 'url', url: trimmed, filename: guessAceFilenameFromUrl(trimmed) };
        }
        return null;
      }
      if(Array.isArray(item)){
        // Arrays are handled by extractAceAudios walker, but keep a fallback
        for(const entry of item){
          const found = aceItemToSource(entry);
          if(found) return found;
        }
        return null;
      }
      if(typeof item !== 'object') return null;

      const filename = item.filename || item.file_name || item.name || item.originalName || null;
      const typeRaw = item.type || item.kind || '';
      const contentTypeRaw = item.content_type || item.contentType || item.mime || '';
      const lowerType = typeof typeRaw === 'string' ? typeRaw.toLowerCase() : '';
      const lowerContentType = typeof contentTypeRaw === 'string' ? contentTypeRaw.toLowerCase() : '';
      const fallbackDuration = findAceDurationSeconds(item);

      if(lowerType === 'base64' && item.data){
        const mime = lowerContentType || 'audio/ogg';
        return finalizeAceSource({
          kind: 'data',
          url: `data:${mime};base64,${item.data}`,
          filename: filename || guessAceFilenameFromDataUri(`data:${mime}`)
        }, item, fallbackDuration);
      }

      const candidateKeys = ['url', 'data', 'path', 'location', 'signed_url', 'signedUrl', 'downloadUrl', 'download_url'];
      for(const key of candidateKeys){
        const value = item[key];
        if(typeof value !== 'string') continue;
        const trimmed = value.trim();
        if(trimmed.startsWith('data:audio/')){
          return finalizeAceSource({ kind: 'data', url: trimmed, filename: filename || guessAceFilenameFromDataUri(trimmed) }, item, fallbackDuration);
        }
        if(/^https?:/i.test(trimmed) && (audioPattern.test(trimmed) || lowerType.includes('audio') || lowerContentType.startsWith('audio'))){
          return finalizeAceSource({ kind: 'url', url: trimmed, filename: filename || guessAceFilenameFromUrl(trimmed) }, item, fallbackDuration);
        }
      }

      if((lowerType && lowerType.startsWith('audio')) || (lowerContentType && lowerContentType.startsWith('audio'))){
        if(item.data && typeof item.data === 'string'){
          if(item.data.startsWith('http')){
            return finalizeAceSource({ kind: 'url', url: item.data, filename: filename || guessAceFilenameFromUrl(item.data) }, item, fallbackDuration);
          }
          if(item.data.startsWith('data:audio/')){
            return finalizeAceSource({ kind: 'data', url: item.data, filename: filename || guessAceFilenameFromDataUri(item.data) }, item, fallbackDuration);
          }
          return finalizeAceSource({
            kind: 'data',
            url: `data:${lowerContentType || lowerType};base64,${item.data}`,
            filename: filename || guessAceFilenameFromDataUri(`data:${lowerContentType || lowerType}`)
          }, item, fallbackDuration);
        }
      }

      if(item.bucket && item.key && typeof item.bucket === 'string' && typeof item.key === 'string'){
        const s3Url = item.key.startsWith('http') ? item.key : `https://${item.bucket}.s3.amazonaws.com/${item.key.replace(/^\//, '')}`;
        if(/^https?:/i.test(s3Url)){
          return finalizeAceSource({ kind: 'url', url: s3Url, filename: filename || guessAceFilenameFromUrl(s3Url) }, item, fallbackDuration);
        }
      }

      if(item.data && typeof item.data === 'object'){
        const nested = aceItemToSource(item.data);
        if(nested){
          if((!Number.isFinite(nested.duration) || nested.duration <= 0) && Number.isFinite(fallbackDuration) && fallbackDuration > 0){
            nested.duration = fallbackDuration;
          }
          return nested;
        }
      }
      if(item.output && typeof item.output === 'object'){
        const nested = aceItemToSource(item.output);
        if(nested){
          if((!Number.isFinite(nested.duration) || nested.duration <= 0) && Number.isFinite(fallbackDuration) && fallbackDuration > 0){
            nested.duration = fallbackDuration;
          }
          return nested;
        }
      }
      if(item.result && typeof item.result === 'object'){
        const nested = aceItemToSource(item.result);
        if(nested){
          if((!Number.isFinite(nested.duration) || nested.duration <= 0) && Number.isFinite(fallbackDuration) && fallbackDuration > 0){
            nested.duration = fallbackDuration;
          }
          return nested;
        }
      }

      let fileId = item.fileId || item.file_id || null;
      if(!fileId && item.id && (lowerType === 'file' || lowerType === 'output')) fileId = item.id;
      const hasExplicitUrl = candidateKeys.some(key => typeof item[key] === 'string' && item[key].trim().startsWith('http'));
      if(!fileId && item.id && (filename || item.name) && !hasExplicitUrl) fileId = item.id;
      if(fileId){
        const inferredName = filename || item.name || guessAceFilenameFromUrl(item.path || item.key || '');
        return finalizeAceSource({
          kind: 'file',
          fileId,
          filename: inferredName || 'audio.ogg'
        }, item, fallbackDuration);
      }

      return null;
    }

    function extractAceAudios(data){
      const ready = [];
      const pending = [];
      const seenUrls = new Set();
      const seenFiles = new Set();
      const visited = new WeakSet();

      function pushSource(src){
        if(!src) return;
        if(src.kind === 'file'){
          const fid = src.fileId;
          if(fid && !seenFiles.has(fid)){
            seenFiles.add(fid);
            pending.push({ fileId: fid, filename: src.filename || 'audio.ogg', duration: Number.isFinite(src.duration) && src.duration > 0 ? src.duration : null });
          }
          return;
        }
        const url = src.url;
        if(!url || seenUrls.has(url)) return;
        seenUrls.add(url);
        const name = src.filename || (src.kind === 'data' ? guessAceFilenameFromDataUri(url) : guessAceFilenameFromUrl(url));
        const entry = { url, filename: name, cleanup: src.cleanup };
        if(Number.isFinite(src.duration) && src.duration > 0) entry.duration = src.duration;
        ready.push(entry);
      }

      function walk(node){
        if(node === null || node === undefined) return;
        if(typeof node === 'string'){
          const trimmed = node.trim();
          if(!trimmed) return;
          const maybe = aceItemToSource(trimmed);
          if(maybe) pushSource(maybe);
          return;
        }
        if(typeof node === 'number' || typeof node === 'boolean') return;
        if(Array.isArray(node)){
          for(const item of node) walk(item);
          return;
        }
        if(typeof node === 'object'){
          if(visited.has(node)) return;
          visited.add(node);
          pushSource(aceItemToSource(node));
          for(const key of Object.keys(node)){
            if(key === 'id' || key === 'status' || key === 'executionTime' || key === 'delayTime' || key === 'workerId') continue;
            walk(node[key]);
          }
        }
      }

      walk(data);
      return { ready, pending };
    }

    async function downloadAceFile(key, jobId, fileId, filename){
      if(!fileId) return null;
      const headers = { 'Authorization': `Bearer ${key}` };
      const bases = new Set();
      bases.add(`${ACE_FILE_ENDPOINT}/${fileId}`);
      bases.add(`${ACE_FILES_ENDPOINT}/${fileId}`);
      bases.add(`${ACE_BASE_ENDPOINT}/output/${fileId}`);
      if(jobId){
        bases.add(`${ACE_RUNS_ENDPOINT}/${jobId}/output/${fileId}`);
        bases.add(`${ACE_RUNS_ENDPOINT}/${jobId}/file/${fileId}`);
        bases.add(`${ACE_RUN_ENDPOINT}/${jobId}/output/${fileId}`);
        bases.add(`${ACE_ENDPOINT}/${jobId}/output/${fileId}`);
        bases.add(`${ACE_ENDPOINT}/${jobId}/file/${fileId}`);
      }
      const queries = ['', '?download=1', '?rp_download=1', '?rp_download=true'];
      const baseVariants = new Set();
      for(const base of bases){
        baseVariants.add(base);
        baseVariants.add(`${base}/download`);
      }
      for(const base of baseVariants){
        for(const q of queries){
          const target = `${base}${q}`;
          try{
            const resp = await fetch(target, { headers });
            if(!resp.ok) continue;
            const contentType = resp.headers.get('content-type') || '';
            const headerDuration = parseAceDurationToSeconds(resp.headers.get('x-runpod-duration') || resp.headers.get('x-runpod-audio-seconds') || resp.headers.get('content-duration'));
            if(contentType.includes('application/json')){
              const json = await resp.json();
              const src = aceItemToSource(json);
              if(src && src.kind !== 'file'){
                if((!Number.isFinite(src.duration) || src.duration <= 0) && Number.isFinite(headerDuration) && headerDuration > 0){
                  src.duration = headerDuration;
                }
                const out = { url: src.url, filename: src.filename || filename || 'audio.ogg' };
                if(Number.isFinite(src.duration) && src.duration > 0) out.duration = src.duration;
                if(typeof src.cleanup === 'function') out.cleanup = src.cleanup;
                return out;
              }
              continue;
            }
            const blob = await resp.blob();
            const name = parseContentDispositionFilename(resp.headers.get('content-disposition')) || filename || 'audio.ogg';
            const blobUrl = URL.createObjectURL(blob);
            const out = { url: blobUrl, filename: name, cleanup: () => URL.revokeObjectURL(blobUrl) };
            if(Number.isFinite(headerDuration) && headerDuration > 0) out.duration = headerDuration;
            return out;
          } catch(err){
            console.debug('ACE download candidate failed', target, err);
          }
        }
      }
      return null;
    }

    function addAceTrack(entry){
      if(!entry || !acel.gallery) return;
      const url = entry.url;
      if(!url) return;
      const name = entry.filename || guessAceFilenameFromUrl(url);
      const wrap = document.createElement('div');
      wrap.className = 'shot';
      const header = document.createElement('div');
      header.className = 'header';
      const titleWrap = document.createElement('div');
      titleWrap.style.display = 'flex';
      titleWrap.style.flexDirection = 'column';
      titleWrap.style.gap = '4px';
      titleWrap.style.minWidth = '0';
      const title = document.createElement('span');
      title.className = 'mono';
      title.textContent = name;
      title.title = name;
      title.style.wordBreak = 'break-word';
      const durationLabel = document.createElement('span');
      durationLabel.className = 'hint';
      durationLabel.textContent = 'Length: loadingâ€¦';
      titleWrap.appendChild(title);
      titleWrap.appendChild(durationLabel);
      const download = document.createElement('a');
      download.className = 'btn';
      download.href = url;
      download.download = name;
      download.textContent = 'Download';
      header.appendChild(titleWrap);
      header.appendChild(download);
      wrap.appendChild(header);
      const audio = document.createElement('audio');
      audio.controls = true;
      audio.preload = 'metadata';
      audio.src = url;
      audio.style.width = '100%';
      const applyDuration = seconds => {
        const text = formatAceDurationLabel(seconds);
        if(text){
          durationLabel.textContent = text;
          durationLabel.title = text;
          durationLabel.dataset.hasDuration = 'true';
        }
      };
      const initialDuration = parseAceDurationToSeconds(entry.duration);
      if(Number.isFinite(initialDuration) && initialDuration > 0){
        applyDuration(initialDuration);
      }
      const handleDurationEvent = () => {
        const dur = audio.duration;
        if(Number.isFinite(dur) && dur > 0){ applyDuration(dur); return; }
        if(audio.seekable && audio.seekable.length){
          const end = audio.seekable.end(audio.seekable.length - 1);
          if(Number.isFinite(end) && end > 0){ applyDuration(end); }
        }
      };
      audio.addEventListener('loadedmetadata', handleDurationEvent);
      audio.addEventListener('durationchange', handleDurationEvent);
      audio.addEventListener('loadeddata', handleDurationEvent);
      audio.addEventListener('error', ()=>{
        if(!durationLabel.dataset.hasDuration){
          durationLabel.textContent = 'Length: unavailable';
          durationLabel.removeAttribute('title');
        }
      });
      if(audio.readyState >= 1) handleDurationEvent();
      wrap.appendChild(audio);
      if(entry.cleanup && typeof entry.cleanup === 'function'){
        aceBlobCleanups.push(entry.cleanup);
      }
      acel.gallery.prepend(wrap);
    }

    async function runAce(){
      const key = (acel.apiKey && acel.apiKey.value || '').trim();
      if(!key){ if(acel.status) acel.status.textContent = 'API key required'; return; }
      try{
        setAceBusy(true);
        const payload = buildAcePayload();
        if(acel.debugReq) acel.debugReq.textContent = JSON.stringify(payload, null, 2);
        const resp = await fetch(ACE_ENDPOINT, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${key}`, 'Content-Type':'application/json' },
          body: JSON.stringify(payload)
        });
        let data = await resp.json();
        let jobId = data && data.id ? data.id : null;
        if(acel.debugResp) acel.debugResp.textContent = JSON.stringify(data, null, 2);

        if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
        if(data.status !== 'COMPLETED'){
          if(data.id){
            if(acel.status) acel.status.textContent = 'Waiting for job...';
            data = await pollStatus(key, data.id, acel.debugResp, ACE_STATUS_ENDPOINT);
            if(data && data.id) jobId = data.id;
          } else {
            throw new Error(`Job status: ${data.status}`);
          }
        }

        const { ready, pending } = extractAceAudios(data);
        const tracks = [...ready];
        if(pending.length && acel.status) acel.status.textContent = 'Fetching audio filesâ€¦';
        for(const file of pending){
          const downloaded = await downloadAceFile(key, jobId, file.fileId, file.filename);
          if(downloaded){
            if(Number.isFinite(file.duration) && file.duration > 0 && (!Number.isFinite(downloaded.duration) || downloaded.duration <= 0)){
              downloaded.duration = file.duration;
            }
            tracks.push(downloaded);
          }
        }
        if(!tracks.length){
          const workerStatus = data && data.output && data.output.status ? data.output.status : null;
          throw new Error(workerStatus ? `No audio returned (worker status: ${workerStatus})` : 'No audio returned');
        }

        for(const item of tracks){
          addAceTrack(item);
        }
        if(acel.status) acel.status.textContent = `Completed in ${data.executionTime ?? '?'} ms`;
      } catch(err){
        console.error(err);
        if(acel.status) acel.status.innerHTML = `<span class="error">Error: ${err.message}</span>`;
      } finally { setAceBusy(false); }
    }

    if(acel.runBtn) acel.runBtn.addEventListener('click', (e)=>{ e.preventDefault(); runAce(); });
    if(acel.curlBtn) acel.curlBtn.addEventListener('click', ()=>{
      const payload = buildAcePayload();
      const text = makeAceCurl(payload);
      if(navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(text).then(()=>{ if(acel.status) acel.status.textContent = 'cURL copied'; });
      }
    });

    if(acel.resetBtn) acel.resetBtn.addEventListener('click', ()=>{
      if(acel.tags) acel.tags.value = '';
      if(acel.structure) acel.structure.value = '';
      if(acel.minutes) acel.minutes.value = 0;
      if(acel.seconds) acel.seconds.value = 30;
      if(acel.seed) acel.seed.value = -1;
      if(acel.steps) acel.steps.value = 50;
      if(acel.cfg) acel.cfg.value = 5.0;
      if(acel.sampler) acel.sampler.value = 'res_multistep';
      if(acel.scheduler) acel.scheduler.value = 'linear_quadratic';
      if(acel.quality) acel.quality.value = '128k';
      if(acel.seedHint) acel.seedHint.textContent = acel.seedHintDefault;
      if(acel.status) acel.status.textContent = 'Reset to defaults';
    });

    if(acel.clearBtn) acel.clearBtn.addEventListener('click', ()=>{
      if(acel.gallery) acel.gallery.innerHTML = '';
      while(aceBlobCleanups.length){
        const fn = aceBlobCleanups.pop();
        try{ if(typeof fn === 'function') fn(); } catch(err){ console.debug('ACE cleanup error', err); }
      }
      if(acel.status) acel.status.textContent = 'Outputs cleared';
    });

    // Initialize
    (function(){
      el.dims.value = '1024x1024';
    })();
  </script>


<script>
  // --- Tabs: label the existing main and wire toggling without changing SDXL code ---
  (function(){
    const sdxlMain = document.querySelector('body > main') || document.querySelector('main');
    const qwenMain = document.getElementById('qwen-main');
    const aceMain = document.getElementById('ace-main');
    const wanMain = document.getElementById('wan-main');
    const tabbar = document.getElementById('tabbar');
    if (!sdxlMain || !tabbar) return;
    sdxlMain.id = 'sdxl-main';
    const sections = { sdxl: sdxlMain };
    if(qwenMain) sections.qwen = qwenMain;
    if(aceMain) sections.ace = aceMain;
    if(wanMain) sections.wan = wanMain;
    tabbar.addEventListener('click', (e)=>{
      const btn = e.target.closest('.tab'); if(!btn) return;
      const tab = btn.dataset.tab;
      if(!tab || !sections[tab]) return;
      for(const b of tabbar.querySelectorAll('.tab')) b.classList.remove('active');
      btn.classList.add('active');
      for (const key of Object.keys(sections)){
        if(key === tab) sections[key].classList.remove('hidden');
        else sections[key].classList.add('hidden');
      }
    });
  })();

  // --- Qwen element helpers ---
  const q = id => document.getElementById(id);
  const qel = {
    apiKey: document.getElementById('apiKey'),
    prompt: q('q-prompt'),
    lowstep: q('q-lowstep'),
    negative: q('q-negative'), negwrap: q('q-negwrap'),
    width: q('q-width'), height: q('q-height'),
    seed: q('q-seed'), seedHint: q('q-seedHint'), steps: q('q-steps'), stepsWrap: q('q-steps-wrap'),
    cfg: q('q-cfg'), sampler: q('q-sampler'), scheduler: q('q-scheduler'),
    modelShift: q('q-model-shift'),
    runBtn: q('q-run'), curlBtn: q('q-curl'), resetBtn: q('q-reset'), clearBtn: q('q-clear'),
    status: q('q-status'), timer: q('q-timer'), gallery: q('q-gallery'), debugReq: q('q-debugReq'), debugResp: q('q-debugResp'),
  };

  const qtimer = makeTimer(qel.timer);

  qel.seedHintDefault = qel.seedHint ? qel.seedHint.textContent : '';

  populateSelect(qel.sampler, SAMPLERS, 'euler');
  populateSelect(qel.scheduler, SCHEDULERS, 'normal');

  // Low-step toggle behavior
  qel.lowstep.addEventListener('change', ()=>{
    const on = qel.lowstep.checked;
    qel.negwrap.style.display = on ? 'none' : '';
    qel.stepsWrap.style.display = on ? 'none' : '';
    if(on){ qel.steps.value = 8; }
  });

  qel.resetBtn.addEventListener('click', ()=>{
    qel.prompt.value = '';
    qel.lowstep.checked = false; qel.negwrap.style.display=''; qel.stepsWrap.style.display='';
    qel.negative.value = '';
    qel.width.value = 1024; qel.height.value = 1024;
    qel.seed.value = -1; qel.steps.value = 20; qel.cfg.value = 2.0;
    qel.sampler.value = 'euler'; qel.scheduler.value = 'normal';
    qel.modelShift.value = 3.10;
    if(qel.seedHint) qel.seedHint.textContent = qel.seedHintDefault;
    qel.status.textContent = 'Reset to defaults';
  });

  qel.clearBtn.addEventListener('click', ()=>{ qel.gallery.innerHTML=''; qel.status.textContent='Gallery cleared'; });

  function buildQwenPlaceholderMap(){
    let seedVal = parseInt(qel.seed.value || '-1', 10);
    if(seedVal === -1){
      seedVal = genRandomSeed();
      if(qel.seedHint) qel.seedHint.textContent = `Random seed: ${seedVal}`;
    } else if(qel.seedHint){
      qel.seedHint.textContent = qel.seedHintDefault;
    }
    const low = !!qel.lowstep.checked;
    const steps = low ? 8 : Math.max(10, Math.min(30, parseInt(qel.steps.value || '20',10)));
    const cfg = Math.max(1.0, Math.min(3.5, parseFloat((qel.cfg.value || '2.0').toString())));
    const w = Math.max(64, Math.min(1920, parseInt(qel.width.value || '1024',10)));
    const h = Math.max(64, Math.min(1920, parseInt(qel.height.value || '1024',10)));
    const shift = Math.max(0, parseFloat((qel.modelShift.value || '3.10')).toFixed(2));
    return {
      use_low_step: low,
      prompt: qel.prompt.value || '',
      negative_prompt: low ? '' : (qel.negative.value || ''),
      width: w, height: h,
      seed: seedVal, steps: steps,
      cfg: parseFloat(cfg.toFixed(1)),
      sampler: qel.sampler.value,
      scheduler: qel.scheduler.value,
      model_shift: shift
    };
  }

  function getQwenTemplate(){
    const el = document.getElementById('qwen-template');
    if(!el) throw new Error('Missing qwen-template');
    const raw = el.textContent.trim();
    return JSON.parse(raw);
  }

  function deepReplacePlaceholdersQ(obj, map){
    if (obj === null || obj === undefined) return obj;
    if (typeof obj === 'string'){
      const m = obj.match(/^%([a-zA-Z0-9_]+)%$/);
      if (m){
        const key = m[1];
        if (!(key in map)) throw new Error(`Missing placeholder: ${key}`);
        return map[key];
      }
      return obj;
    } else if (Array.isArray(obj)){
      return obj.map(v => deepReplacePlaceholdersQ(v, map));
    } else if (typeof obj === 'object'){
      const out = {};
      for (const k of Object.keys(obj)) out[k] = deepReplacePlaceholdersQ(obj[k], map);
      return out;
    }
    return obj;
  }

  function buildQwenPayload(){
    const template = getQwenTemplate();
    const map = buildQwenPlaceholderMap();
    const resolved = deepReplacePlaceholdersQ(template, map);
    return { input: { workflow: resolved } };
  }

  function makeQwenCurl(payload){
    const key = (qel.apiKey && qel.apiKey.value || '').trim() || '<api_key>';
    return [
      'curl -sX POST',
      `  -H "Authorization: Bearer ${key}"`,
      '  -H "Content-Type: application/json"',
      `  -d '${JSON.stringify(payload)}'`,
      `  ${ENDPOINT}`
    ].join(' \\n');
  }

  function setQBusy(b){
    if(qel.runBtn) qel.runBtn.disabled = b;
    if(qel.status) qel.status.textContent = b? 'Runningâ€¦' : 'Idle';
    if(qel.timer){ b ? qtimer.start() : qtimer.stop(); }
  }

  function addQShot(url, name){
    const wrap = document.createElement('div');
    wrap.className = 'shot';
    const header = document.createElement('div'); header.className = 'header';
    header.innerHTML = `<header><span class="mono" title="${name}">${name}</span><a class="btn" href="${url}" download>Download</a></header>`;
    wrap.appendChild(header);
    const img = new Image(); img.loading = 'lazy'; img.src = url; img.addEventListener('click', ()=>openLightbox(url)); wrap.appendChild(img);
    qel.gallery.prepend(wrap);
  }

  async function runQwen(){
    const key = (qel.apiKey && qel.apiKey.value || '').trim();
    if(!key){ if(qel.status) qel.status.textContent = 'API key required'; return; }
    try{
      setQBusy(true);
      const payload = buildQwenPayload();
      if(qel.debugReq) qel.debugReq.textContent = JSON.stringify(payload, null, 2);
      const resp = await fetch(ENDPOINT, {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${key}`, 'Content-Type':'application/json' },
        body: JSON.stringify(payload)
      });
      let data = await resp.json();
      if(qel.debugResp) qel.debugResp.textContent = JSON.stringify(data, null, 2);

      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      if (data.status !== 'COMPLETED'){
        if(data.id){
          if(qel.status) qel.status.textContent = 'Waiting for job...';
          data = await pollStatus(key, data.id, qel.debugResp);
        }else{
          throw new Error(`Job status: ${data.status}`);
        }
      }
      if (!data.output || !Array.isArray(data.output.images) || data.output.images.length === 0) throw new Error('No images in response');

      for (const item of data.output.images){
        if (item.type === 'base64' && item.data){
          const imgUrl = `data:image/avif;base64,${item.data}`;
          addQShot(imgUrl, item.filename || 'image.avif');
        } else if (item.type === 's3_url' && item.data){
          addQShot(item.data, item.filename || 'image.avif');
        }
      }
      if(qel.status) qel.status.textContent = `Completed in ${data.executionTime ?? '?'} ms`;
    } catch(err){
      console.error(err);
      if(qel.status) qel.status.innerHTML = `<span class="error">Error: ${err.message}</span>`;
    } finally{ setQBusy(false); }
  }

  if (qel.runBtn) qel.runBtn.addEventListener('click', (e)=>{ e.preventDefault(); runQwen(); });
  if (qel.curlBtn) qel.curlBtn.addEventListener('click', ()=>{
    const payload = buildQwenPayload();
    const text = makeQwenCurl(payload);
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(()=>{ if(qel.status) qel.status.textContent = 'cURL copied'; });
    }
  });
</script>

<script>
  const lightbox = document.getElementById('lightbox');
  const lightboxImg = lightbox.querySelector('img');
  const lightboxClose = lightbox.querySelector('.close');
  function openLightbox(src){
    lightboxImg.src = src;
    lightbox.classList.remove('hidden');
  }
  function closeLightbox(){
    lightbox.classList.add('hidden');
    lightboxImg.src = '';
  }
  lightbox.addEventListener('click', (e)=>{ if(e.target === lightbox) closeLightbox(); });
  if (lightboxClose) lightboxClose.addEventListener('click', closeLightbox);
  window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closeLightbox(); });
</script>

</body>
</html>
